name: RFC Controller

on:
  issues:
    types: [opened, edited, labeled, closed, deleted]
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, edited, synchronize, closed]

concurrency:
  group: rfc-${{ github.event.issue.number }}-${{ github.event.action }}
  cancel-in-progress: false

permissions:
  contents: read
  issues: write
  repository-projects: write
  pull-requests: read

env:
  PROJECT_URL: https://github.com/orgs/MyCSW/projects/2
  ORG_LOGIN: MyCSW
  USER_LOGIN: ErickGuerron
  PROJECT_NUMBER: 2
  PROJECT_TITLE: Formularios-Develops-ORG
  PROJECT_NUMBER_USER: 3
  PROJECT_TITLE_USER: Formularios-Usuario_Final-ORG

jobs:
  # --- Job: process_rfc_on_github ---
  process_rfc_on_github:
    if: |
      github.event_name == 'issues' &&
      (github.event.action == 'opened' || github.event.action == 'edited' || github.event.action == 'closed')
    runs-on: ubuntu-latest
    steps:
      - name: Add labels, Add to Project, and Map Fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const issue = context.payload.issue;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const body = issue.body || '';
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();

            function escRE(s) {
              return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            const grab = (label) => {
              const L = escRE(label);
              const variants = [
                new RegExp(
                  `^###\\s*${L}\\s*\\n+([\\s\\S]*?)(?=\\n###|\\n$|$)`,
                  'im'
                ),
                new RegExp(
                  `\\*\\*${L}\\*\\*[\\s\\r\\n]+([\\s\\S]*?)(?=\\n\\*\\*|\\n###|\\n$|$)`,
                  'i'
                ),
                new RegExp(`^${L}\\s*:\\s*(.+)$`, 'im')
              ];
              for (const re of variants) {
                const m = body.match(re);
                if (m) return m[1].trim();
              }
              return '';
            };

            // Logging helper with timestamp and prefix
            const log = (msg, data = null) => {
              const timestamp = new Date().toISOString();
              console.log(`[${timestamp}] [rfc-project] ${msg}`);
              if (data) {
                console.log(JSON.stringify(data, null, 2));
              }
            };

            const tipo   = (grab('Tipo de cambio') || '').toLowerCase();
            const riesgo = (grab('Riesgo') || '').toLowerCase();

            const wanted = new Set(['rfc']);
            if (tipo.includes('est√°ndar') || tipo.includes('estandar')) wanted.add('tipo:estandar');
            if (tipo.includes('normal'))                                wanted.add('tipo:normal');
            if (tipo.includes('emergencia') || tipo.includes('urgente')) wanted.add('tipo:emergencia');
            if (riesgo.includes('bajo'))  wanted.add('riesgo:bajo');
            if (riesgo.includes('medio')) wanted.add('riesgo:medio');
            if (riesgo.includes('alto'))  wanted.add('riesgo:alto');

            const current = new Set((issue.labels || []).map(l => l.name));
            const toAdd = [...wanted].filter(l => !current.has(l));
            if (toAdd.length) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: issue.number,
                labels: toAdd
              });
            }

            const hasUserLabel = (issue.labels || []).some(
              (l) => norm(l.name) === 'user'
            );

            // =========================
            // Resoluci√≥n de Projects (ORG primero, luego USER)
            // =========================
            const ORG_LOGIN  = (process.env.ORG_LOGIN || '').trim();
            const USER_LOGIN = (process.env.USER_LOGIN || context.repo.owner).trim();

            const PROJECT_NUMBER       = parseInt(process.env.PROJECT_NUMBER || '0', 10);
            const PROJECT_TITLE        = (process.env.PROJECT_TITLE || '').trim();
            const PROJECT_NUMBER_USER  = parseInt(process.env.PROJECT_NUMBER_USER || '0', 10);
            const PROJECT_TITLE_USER   = (process.env.PROJECT_TITLE_USER || '').trim();
            const PROJECT_URL          = (process.env.PROJECT_URL || '').trim();

            // DEBUG: Mostrar configuraci√≥n
            log(`üìã Configuraci√≥n detectada:`);
            log(`  ORG_LOGIN: ${ORG_LOGIN || 'NO CONFIGURADO'}`);
            log(`  USER_LOGIN: ${USER_LOGIN}`);
            log(`  PROJECT_NUMBER: ${PROJECT_NUMBER}`);
            log(`  PROJECT_TITLE: ${PROJECT_TITLE}`);
            log(`  PROJECT_URL: ${PROJECT_URL}`);
            log(`  Issue: #${issue.number}`);
            log(`  Labels: ${(issue.labels || []).map(l => l.name).join(', ')}`);

            async function resolveFromUrl(url){
              if (!url) return null;

              // Caso: proyectos de usuario
              let mu = url.match(/https:\/\/github\.com\/users\/([^/]+)\/projects\/(\d+)/i);
              if (mu) {
                const login = mu[1];
                const num   = parseInt(mu[2],10);
                log(`üîç resolveFromUrl (user) login=${login} num=${num}`);
                const r = await github.graphql(
                  `query($login:String!){
                    user(login:$login){
                      projectsV2(first:100){
                        nodes{ id number title }
                      }
                    }
                  }`,
                  { login }
                ).catch(e => {
                  log(`‚ùå GraphQL user error en resolveFromUrl: ${e.message}`);
                  return null;
                });
                const hit = r?.user?.projectsV2?.nodes?.find(n => n.number === num);
                if (hit) {
                  log(`‚úÖ Proyecto de usuario encontrado via URL: ${hit.id}`);
                  return hit.id;
                }
              }

              // Caso: proyectos de organizaci√≥n
              mu = url.match(/https:\/\/github\.com\/orgs\/([^/]+)\/projects\/(\d+)/i);
              if (mu) {
                const login = mu[1];
                const num   = parseInt(mu[2],10);
                log(`üîç resolveFromUrl (org) login=${login} num=${num}`);
                const r = await github.graphql(
                  `query($login:String!){
                    organization(login:$login){
                      projectsV2(first:100){
                        nodes{ id number title }
                      }
                    }
                  }`,
                  { login }
                ).catch(e => {
                  log(`‚ùå GraphQL org error en resolveFromUrl: ${e.message}`);
                  return null;
                });
                const hit = r?.organization?.projectsV2?.nodes?.find(n => n.number === num);
                if (hit) {
                  log(`‚úÖ Proyecto de organizaci√≥n encontrado via URL: ${hit.id}`);
                  return hit.id;
                }
              }

              log(`‚ö†Ô∏è resolveFromUrl no pudo resolver proyecto desde: ${url}`);
              return null;
            }

            async function resolveByUser(numberOrTitle){
              try {
                const r = await github.graphql(
                  `query($login:String!){
                    user(login:$login){
                      projectsV2(first:100){
                        nodes{ id number title }
                      }
                    }
                  }`,
                  { login: USER_LOGIN }
                ).catch(e => {
                  log(`‚ùå GraphQL user error: ${e.message}`);
                  return null;
                });
                const nodes = r?.user?.projectsV2?.nodes || [];
                if (typeof numberOrTitle === 'number' && numberOrTitle > 0) {
                  const found = nodes.find(n => n.number === numberOrTitle);
                  if (found) {
                    log(`‚úÖ Proyecto de usuario encontrado por n√∫mero: ${found.id}`);
                  }
                  return found?.id || null;
                }
                if (typeof numberOrTitle === 'string' && numberOrTitle) {
                  const found = nodes.find(n => n.title === numberOrTitle);
                  if (found) {
                    log(`‚úÖ Proyecto de usuario encontrado por t√≠tulo: ${found.id}`);
                  }
                  return found?.id || null;
                }
              } catch(e) {
                log(`‚ùå resolveByUser exception: ${e.message}`);
              }
              return null;
            }

            async function resolveByOrg(numberOrTitle) {
              if (!ORG_LOGIN) {
                log('‚ö†Ô∏è ORG_LOGIN no est√° configurado');
                return null;
              }
              
              try {
                log(`üîç Consultando proyectos de la organizaci√≥n ${ORG_LOGIN}...`);
                const r = await github.graphql(
                  `query($login:String!){
                    organization(login:$login){
                      projectsV2(first:100){
                        nodes { 
                          id 
                          number 
                          title 
                        }
                      }
                    }
                  }`,
                  { login: ORG_LOGIN }
                ).catch(e => { 
                  log(`‚ùå GraphQL org error: ${e.message}`); 
                  log(`   Esto puede indicar que el PAT no tiene permisos de organizaci√≥n`);
                  return null; 
                });

                if (!r || !r.organization) {
                  log(`‚ùå No se pudo acceder a la organizaci√≥n ${ORG_LOGIN}`);
                  log(`   Verifica que el PAT tenga scope 'read:org'`);
                  return null;
                }

                const nodes = (r?.organization?.projectsV2?.nodes || []).filter(Boolean);
                log(`‚úÖ Proyectos encontrados en ORG: ${nodes.length}`);
                nodes.forEach(n => log(`   - #${n.number}: "${n.title}"`));

                if (typeof numberOrTitle === 'number' && numberOrTitle > 0) {
                  const found = nodes.find(n => n.number === numberOrTitle);
                  if (found) {
                    log(`‚úÖ Match por n√∫mero: ${found.id}`);
                  }
                  return found?.id || null;
                }
                
                if (typeof numberOrTitle === 'string' && numberOrTitle) {
                  const found = nodes.find(n => n.title === numberOrTitle);
                  if (found) {
                    log(`‚úÖ Match por t√≠tulo: ${found.id}`);
                  }
                  return found?.id || null;
                }
              } catch (e) {
                log(`‚ùå resolveByOrg exception: ${e.message}`);
                log(`   Stack: ${e.stack}`);
              }
              return null;
            }

            async function findProjectV2Main() {
              log('=== Iniciando b√∫squeda de proyecto principal ===');
              
              // 1) Intentar por URL primero (M√ÅS CONFIABLE)
              if (PROJECT_URL) {
                log(`Intentando resolver desde URL: ${PROJECT_URL}`);
                const id = await resolveFromUrl(PROJECT_URL);
                if (id) {
                  log(`‚úÖ Proyecto encontrado via URL: ${id}`);
                  return id;
                }
              }

              // 2) Buscar en Projects de la ORGANIZACI√ìN (PRIORIDAD)
              if (ORG_LOGIN) {
                log(`Buscando en organizaci√≥n: ${ORG_LOGIN}`);
                
                // Intentar por n√∫mero primero
                if (PROJECT_NUMBER > 0) {
                  log(`Buscando proyecto #${PROJECT_NUMBER} en ORG`);
                  const id = await resolveByOrg(PROJECT_NUMBER);
                  if (id) {
                    log(`‚úÖ Proyecto encontrado por n√∫mero en ORG: ${id}`);
                    return id;
                  }
                }
                
                // Intentar por t√≠tulo
                if (PROJECT_TITLE) {
                  log(`Buscando proyecto "${PROJECT_TITLE}" en ORG`);
                  const id = await resolveByOrg(PROJECT_TITLE);
                  if (id) {
                    log(`‚úÖ Proyecto encontrado por t√≠tulo en ORG: ${id}`);
                    return id;
                  }
                }
              }

              // 3) Fallback: Projects del usuario (SOLO SI NO SE ENCONTR√ì EN ORG)
              log('No encontrado en ORG, intentando en usuario...');
              if (PROJECT_NUMBER > 0) {
                const id = await resolveByUser(PROJECT_NUMBER);
                if (id) {
                  log(`‚ö†Ô∏è Proyecto encontrado en USER (fallback): ${id}`);
                  return id;
                }
              }
              if (PROJECT_TITLE) {
                const id = await resolveByUser(PROJECT_TITLE);
                if (id) {
                  log(`‚ö†Ô∏è Proyecto encontrado en USER (fallback): ${id}`);
                  return id;
                }
              }

              log('‚ùå Project principal NO encontrado en ORG ni en USER');
              return null;
            }

            async function findProjectV2User() {
              return await resolveByUser(PROJECT_NUMBER_USER) || await resolveByUser(PROJECT_TITLE_USER);
            }

            const issueRes = await github.graphql(
              `query($owner:String!, $name:String!, $n:Int!){
                repository(owner:$owner, name:$name){ issue(number:$n){ id number } }
              }`,
              { owner, name: repo, n: issue.number }
            );
            const issueId = issueRes.repository.issue.id;
            log(`‚úÖ Issue ID obtenido: ${issueId}`);

            // Validaci√≥n de owner vs ORG_LOGIN
            if (ORG_LOGIN && owner !== ORG_LOGIN) {
              log(`‚ö†Ô∏è Owner del repo (${owner}) no coincide con ORG_LOGIN esperado (${ORG_LOGIN})`);
            }

            async function ensureItem(projectId){
              log(`üîç Starting ensureItem for issue #${issue.number}`, {
                projectId,
                issueId,
                issueNumber: issue.number,
                issueTitle: issue.title
              });

              // Validation checks
              if (!projectId) {
                log('‚ùå ERROR: projectId is null or undefined');
                throw new Error('projectId is required but was not provided');
              }
              if (!issueId) {
                log('‚ùå ERROR: issueId is null or undefined');
                throw new Error('issueId is required but was not provided');
              }

              log('Checking if item already exists in project...');

              // Check if item already exists (increased to 100 items)
              try {
                const srch = await github.graphql(
                  `query($projectId:ID!, $q:String!){
                    node(id:$projectId){ ... on ProjectV2 {
                      items(first:100, query:$q){
                        nodes{
                          id
                          content{ ... on Issue { number } }
                        }
                      }
                    } }
                  }`,
                  { projectId, q: String(issue.number) }
                );

                let it = srch?.node?.items?.nodes?.find(n=>n.content?.number===issue.number);
                if (it) {
                  log(`‚úÖ Item already exists in project with ID: ${it.id}`);
                  return it.id;
                }

                log('‚ûï Item not found in project. Adding new item...');

                // Add item to project - WITH PROPER ERROR HANDLING
                const add = await github.graphql(
                  `mutation($projectId:ID!, $contentId:ID!){
                    addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){
                      item { id }
                    }
                  }`,
                  { projectId, contentId: issueId }
                );

                const itemId = add?.addProjectV2ItemById?.item?.id;
                if (itemId) {
                  log(`‚úÖ SUCCESS: Item added to project with ID: ${itemId}`);
                  return itemId;
                } else {
                  log('‚ùå Respuesta de addProjectV2ItemById no contiene item.id');
                  return null;
                }

              } catch(error) {
                // CRITICAL: Log detailed error information
                log('‚ùå CRITICAL ERROR in ensureItem:', {
                  issueNumber: issue.number,
                  issueTitle: issue.title,
                  projectId,
                  issueId,
                  errorMessage: error.message,
                  errorStatus: error.status,
                  errorType: error.constructor.name,
                  errorResponse: error.response?.data,
                  graphqlErrors: error.errors
                });

                // Check for common permission errors
                if (error.message.includes('Resource not accessible by integration') ||
                    error.message.includes('Must have write access')) {
                  log('‚ö†Ô∏è PERMISSIONS ERROR: El PAT necesita scope "project" con write access');
                  log('‚ö†Ô∏è Verifica que el token tenga permisos en: https://github.com/settings/tokens');
                }

                // Re-throw to make the workflow fail visibly
                throw new Error(`Failed to add issue #${issue.number} to project: ${error.message}`);
              }
            }

            async function getFields(projectId){
              const r = await github.graphql(
                `query($projectId:ID!){
                  node(id:$projectId){
                    ... on ProjectV2 {
                      fields(first:100){
                        nodes{
                          ... on ProjectV2FieldCommon { id name dataType }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                        }
                      }
                    }
                  }
                }`,
                { projectId }
              ).catch(()=>null);
              return r?.node?.fields?.nodes || [];
            }

            const setSelect = async(projectId,itemId,field,optName)=>{
              if(!projectId || !itemId || !field || !optName) return;
              const opts = field.options || [];
              const opt = opts.find(o=>norm(o.name)===norm(optName)) || opts.find(o=>norm(o.name).includes(norm(optName)));
              if(!opt) {
                console.log(`Opci√≥n "${optName}" no encontrada en el campo "${field?.name}"`);
                return;
              }
              await github.graphql(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ singleSelectOptionId:$opt }
                  }){
                    clientMutationId
                  }
                }`,
                { projectId, itemId, fieldId: field.id, opt: opt.id }
              ).catch(()=>null);
            }

            const setText = async(projectId,itemId,fieldId,val)=>{
              if(!projectId || !itemId || !fieldId) return;  
              await github.graphql(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $val:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ text:$val }
                  }){
                    clientMutationId
                  }
                }`,
                { projectId, itemId, fieldId: fieldId, val: val || "" }
              ).catch(()=>null);
            }

            const setDate = async(projectId,itemId,fieldId,ymd)=>{
              if(!projectId || !itemId || !fieldId || !ymd) return;
              await github.graphql(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $val:Date!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ date:$val }
                  }){
                    clientMutationId
                  }
                }`,
                { projectId, itemId, fieldId: fieldId, val: ymd }
              ).catch(()=>null);
            }

            // --- RUTA ISSUE USER ---
            if (hasUserLabel) {
              // Intento principal: proyecto de usuario
              let projectIdUser = await findProjectV2User();

              if (!projectIdUser) {
                log('‚ö†Ô∏è Project de usuario no encontrado o sin permisos. Intentando usar el proyecto principal como fallback...');
                projectIdUser = await findProjectV2Main();
              }

              if (!projectIdUser) {
                log('‚ùå No se pudo resolver ning√∫n Project (usuario ni principal) para el formulario de usuario');
                return;
              }

              const itemIdUser = await ensureItem(projectIdUser);
              if (!itemIdUser) {
                log('‚ùå No se pudo crear/encontrar item en Project usuarios/principal');
                return;
              }

              const fieldsUser = await getFields(projectIdUser);
              const byU = (names) => {
                const want = names.map(n => norm(n));
                return fieldsUser.find(f => {
                  const fn = norm(f?.name);
                  return want.some(w => fn === w || fn.includes(w));
                });
              };

              const fStatusU    = byU(['Status']);
              const fStatusCccU = byU(['Status_CCC','Status CCC','status_ccc']);
              const fReasonU    = byU(['Reason for change','Motivo de cambio']);
              const fRiskU      = byU(['Risk','Riesgo']);
              const fSolicU     = byU(['Solicitor']);
              const fDeptU      = byU(['Department','√Årea / Departamento','Area / Departamento']);
              const fEmailU     = byU(['Contact Email']);
              const fDateAppU   = byU(['Date of application']);
              const fDescU      = byU(['Description of the requested change','Description of the request','Descripci√≥n del cambio solicitado']);
              const fExplU      = byU(['Explanation of the reason for the change','Explanation of the reason','Motivo del cambio']);
              const fNotesU     = byU(['Additional comments','Observaciones adicionales']);

              const vDept   = grab('√Årea / Departamento') || grab('Department');
              const vReason = grab('Motivo de cambio'); 
              const vPrior  = grab('Prioridad') || grab('priorityname') || grab('Priority') || '';
              let   vDesc   = grab('Descripci√≥n del cambio solicitado *') || grab('Descripci√≥n del cambio solicitado') || grab('Description of the requested change') || grab('Description of the request');
              let   vExpl   = grab('Motivo del cambio *') || grab('Motivo del cambio') || grab('Explanation of the reason for the change') || grab('Explanation of the reason');
              const vNotes  = grab('Observaciones adicionales') || grab('Additional comments');
              const vEmail  = grab('Email') || grab('Contact Email');

              if(!vDesc) vDesc = (grab('Descripci√≥n del cambio') || '').trim();
              if(!vExpl) vExpl = (grab('Explicaci√≥n del motivo') || '').trim();

              const authorLogin = issue.user?.login || context.actor;
              const authorInfo  = await github.graphql(
                `query($login:String!){
                  user(login:$login){ name }
                }`,
                { login: authorLogin }
              ).catch(()=>null);
              const authorName  = (authorInfo?.user?.name || authorLogin).trim();
              
              function translateReason(reason) {
                const r = norm(reason);
                if (r.includes('correcci√≥n') || r.includes('error')) return 'Error Correction';
                if (r.includes('mejora funcional')) return 'Functional Improvement';
                if (r.includes('est√©tico')) return 'Cosmetic Change';
                if (r.includes('otro')) return 'Other';
                return r;
              }
              const translatedReason = translateReason(vReason);

              function pickRiskFromPriority(priority, riskField){
                const opts = (riskField?.options || []).map(o => o.name);
                const names = opts.map(n => norm(n));
                const high  = opts[names.findIndex(n => /high|alto/.test(n))]   ?? opts.find(o=>/high|alto/i.test(o))   ?? 'High';
                const med   = opts[names.findIndex(n => /medium|medio/.test(n))]?? opts.find(o=>/medium|medio/i.test(o))?? 'Medium';
                const low   = opts[names.findIndex(n => /low|bajo/.test(n))]   ?? opts.find(o=>/low|bajo/i.test(o))   ?? 'Low';
                const v = norm(priority);
                if (/(crit|urg|alta|alto|high)/.test(v))   return high;
                if (/(med|medio|media|medium|normal)/.test(v)) return med;
                if (/(baj|baja|low)/.test(v))              return low;
                return med;
              }

              if (context.payload.action === 'opened') {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'open',
                });
                await setSelect(projectIdUser, itemIdUser, fStatusU, 'Backlog');
                await setSelect(projectIdUser, itemIdUser, fStatusCccU, 'Inbox');
              }

              await setText (projectIdUser, itemIdUser, fSolicU?.id,   authorName);
              await setText (projectIdUser, itemIdUser, fEmailU?.id,   vEmail || '');
              await setDate (projectIdUser, itemIdUser, fDateAppU?.id, new Date().toISOString().slice(0,10));
              await setSelect(projectIdUser, itemIdUser, fReasonU,    translatedReason);
              await setSelect(projectIdUser, itemIdUser, fRiskU,      pickRiskFromPriority(vPrior, fRiskU));
              await setText (projectIdUser, itemIdUser, fDeptU?.id,    vDept);
              await setText (projectIdUser, itemIdUser, fDescU?.id,    vDesc);
              await setText (projectIdUser, itemIdUser, fExplU?.id,    vExpl);
              await setText (projectIdUser, itemIdUser, fNotesU?.id,   vNotes);

              return;
            }

                        
                        // --- RUTA RFC MAIN (sin label user) ---

                        const projectIdMain = await findProjectV2Main();
                        if (!projectIdMain) { console.log('Project principal no encontrado o sin permisos'); return }
                        const itemIdMain = await ensureItem(projectIdMain);
                        if (!itemIdMain) { console.log('No se pudo crear/encontrar item en Project principal'); return }
                        const fieldsMain = await getFields(projectIdMain);
                        const byM = (names)=> {
                          const want = names.map(n => norm(n));
                          return fieldsMain.find(f => {
                            const fn = norm(f?.name);
                            return want.some(w => fn === w || fn.includes(w));
                          });
                        };

                        const fStatusM    = byM(['Status','Estado']);
                        const fStatusCccM = byM(['Status_CCC','Status CCC','status_ccc']);
                        const fTipoM      = byM(['Change Type','Tipo de cambio']);
                        const fRiesgoM    = byM(['Risk','Riesgo']);
                        const fImpactoM   = byM(['Impact','Impacto']);
                        const fPlanM      = byM(['Implementation Plan','Plan de implementaci√≥n']);
                        const fRollbackM  = byM(['RollBack Planning','Rollback Plan','Plan de reversa (rollback)']);
                        const fPruebasM   = byM(['Test Planning','Plan de pruebas']);
                        const fAprobM     = byM(['Approvers','Aprobadores requeridos']);
                        const fSolicM     = byM(['Solicitante','Solicitor','Applicant','Requester']);

                        if (context.payload.action === 'opened') {
                          await github.rest.issues.update({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: issue.number,
                            state: 'open',
                          });
                          await setSelect(projectIdMain, itemIdMain, fStatusM, 'Backlog');
                          await setSelect(projectIdMain, itemIdMain, fStatusCccM, 'Inbox');
                        }

                        await setSelect(projectIdMain, itemIdMain, fTipoM,   tipo);
                        await setSelect(projectIdMain, itemIdMain, fRiesgoM, riesgo);
                        await setText  (projectIdMain, itemIdMain, fImpactoM?.id, grab('Impacto') || grab('Impact'));
                        await setText  (projectIdMain, itemIdMain, fPlanM?.id,    grab('Plan de implementaci√≥n') || grab('Implementation Plan'));
                        await setText  (projectIdMain, itemIdMain, fRollbackM?.id,grab('Plan de reversa \\(rollback\\)') || grab('RollBack Planning') || grab('Rollback Plan'));
                        await setText  (projectIdMain, itemIdMain, fPruebasM?.id, grab('Plan de pruebas') || grab('Test Planning'));
                        await setText  (projectIdMain, itemIdMain, fAprobM?.id,   grab('Aprobadores requeridos') || grab('Approvers'));
                        await setText  (projectIdMain, itemIdMain, fSolicM?.id,   grab('Solicitante') || grab('Solicitor') || grab('Applicant') || grab('Requester'));

                        if (context.payload.action === 'opened') {
                          log('‚úÖ Formulario procesado y agregado al proyecto exitosamente');

                          await github.rest.issues.createComment({
                            owner,
                            repo,
                            issue_number: issue.number,
                            body: `## üìã Formulario Recibido y Procesado

                        El formulario ha sido agregado exitosamente al proyecto para revisi√≥n.

                        **Estado actual:** Cerrado como "Not Planned" (pendiente de aprobaci√≥n)

                        **Pr√≥ximos pasos:**
                        - El equipo CCC revisar√° la solicitud
                        - Para aprobar: Un miembro del equipo CCC agregar√° la etiqueta \`approved\` (la issue se reabrir√° autom√°ticamente)
                        - Para denegar: Se agregar√° la etiqueta \`denied\`

                        **Fecha de procesamiento:** ${new Date().toISOString().slice(0, 19).replace('T', ' ')}`
                          });
                        }

              # --- Job: process-user-approval (Solo para 'user') ---
              process-user-approval:
                if: |
                  github.event_name == 'issues' &&
                  github.event.action == 'labeled' &&
                  (github.event.label.name == 'approved' ||
                    github.event.label.name == 'Approved' ||
                    github.event.label.name == 'aprobado' ||
                    github.event.label.name == 'Aprobado') &&
                  contains(github.event.issue.labels.*.name, 'user')
                runs-on: ubuntu-latest
                steps:
                  - uses: actions/github-script@v7
                    id: check_fields
                    with:
                      github-token: ${{ secrets.PROJECTS_PAT }}
                      script: |
                        const issue = context.payload.issue;
                        const norm = (s) =>
                          (s ?? '')
                            .toString()
                            .normalize('NFD')
                            .replace(/\p{Diacritic}/gu, '')
                            .trim()
                            .toLowerCase();

                        const actor = context.actor;
                        const ORG_LOGIN = process.env.ORG_LOGIN;

                        let isCccMember = false;
                        if (ORG_LOGIN) {
                          try {
                            await github.rest.teams.getMembershipForUserInOrg({
                              org: ORG_LOGIN,
                              team_slug: 'ccc',
                              username: actor
                            });
                            isCccMember = true;
                          } catch (error) {
                            if (error.status === 404) {
                              isCccMember = false;
                            } else {
                              console.log(`Error al verificar membres√≠a: ${error.message}`);
                              isCccMember = false;
                            }
                          }
                        }

            if (!isCccMember) {
              console.log(`Usuario ${actor} no pertenece al equipo "ccc". Acceso denegado.`);
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                name: context.payload.label.name
              }).catch(() => {});
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `## ‚õî Permiso Denegado

              @${actor}, no tienes permisos para aprobar cambios. Solo los miembros del equipo **ccc** pueden aprobar o denegar solicitudes.`
                            });
                            return;
                          }

                          const hasUser = (issue.labels || []).some(
                            (l) => norm(l.name) === 'user'
                          );
                          if (!hasUser) {
                            console.log('Issue no tiene label "user". Saltando.');
                            return;
                          }

                          const USER_LOGIN = process.env.USER_LOGIN;
                          const PN_USER    = parseInt(process.env.PROJECT_NUMBER_USER||'0',10);
                          const userProjUrl = `https://github.com/users/${USER_LOGIN}/projects/${PN_USER}`;

                          async function getUserProjByNum(n){
                            const r = await github.graphql(
                              `query($login:String!){
                                user(login:$login){
                                  projectsV2(first:50){
                                    nodes{ id number }
                                  }
                                }
                              }`,
                              { login: USER_LOGIN }
                            ).catch(()=>null);
                            return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
                          }

                          async function findItemId(projectId, issueNumber){
                            const r = await github.graphql(
                              `query($projectId:ID!, $q:String!){
                                node(id:$projectId){
                                  ... on ProjectV2 {
                                    items(first:50, query:$q){
                                      nodes{
                                        id
                                        content{ ... on Issue { number } }
                                      }
                                    }
                                  }
                                }
                              }`,
                              { projectId, q: String(issueNumber) }
                            );
                            return r.node.items.nodes.find(n=>n.content?.number===issueNumber)?.id || null;
                          }

                          async function getFields(projectId){
                            const r = await github.graphql(
                              `query($projectId:ID!){
                                node(id:$projectId){
                                  ... on ProjectV2 {
                                    fields(first:100){
                                      nodes{
                                        ... on ProjectV2FieldCommon { id name dataType }
                                        ... on ProjectV2SingleSelectField { id name options { id name } }
                                      }
                                    }
                                  }
                                }
                              }`,
                              { projectId }
                            );
                            return r.node.fields.nodes;
                          }

                          async function getFieldValues(itemId){
                            const r = await github.graphql(
                              `query($itemId:ID!){
                                node(id:$itemId){
                                  ... on ProjectV2Item {
                                    fieldValues(first:100){
                                      nodes{
                                        ... on ProjectV2ItemFieldTextValue {
                                          text
                                          field { ... on ProjectV2FieldCommon { id name } }
                                        }
                                        ... on ProjectV2ItemFieldDateValue {
                                          date
                                          field { ... on ProjectV2FieldCommon { id name } }
                                        }
                                        ... on ProjectV2ItemFieldSingleSelectValue {
                                          name
                                          optionId
                                          field { ... on ProjectV2FieldCommon { id name } }
                                        }
                                      }
                                    }
                                  }
                                }
                              }`,
                              { itemId }
                            );
                            return r.node.fieldValues.nodes;
                          }

                          const by = (fields, names) =>
                            names.map(n => fields.find(f => norm(f?.name) === norm(n))).find(Boolean);

                          const projectId = await getUserProjByNum(PN_USER);
                          if(!projectId) {
                            console.log('Proyecto de usuario no encontrado.');
                            return;
                          }
                          const itemId = await findItemId(projectId, issue.number);
                          if(!itemId) {
                            console.log('Item no encontrado en el proyecto.');
                            return;
                          }

                          const fields = await getFields(projectId);
                          const fStatusCcc = by(fields, ['Status_CCC','Status CCC','status_ccc']);
                          const fChangeType= by(fields, ['Change Type', 'Tipo de cambio']);
                          const fImpact    = by(fields, ['Impact']);
                          const fPlan      = by(fields, ['Implementation Plan']);
                          const fRollback  = by(fields, ['RollBack Planning','Rollback Plan']);
                          const fPruebas   = by(fields, ['Test Planning']);
                          const fAprob     = by(fields, ['Approvers']);
                          const fStart     = by(fields, ['Start date']);
                          const fTarget    = by(fields, ['Target date']);

                          const values = await getFieldValues(itemId);
                          function getValue(field){
                            if(!field) return null;
                            const v = values.find(n => norm(n.field?.name) === norm(field.name));
                            if(!v) return null;
                            if ('text' in v) return (v.text||'').trim();
                            if ('date' in v) return (v.date||'').trim();
                            if ('name' in v) return (v.name||'').trim();
                            return null;
                          }

                          const missing = [];
                          if(!getValue(fChangeType)) missing.push('Change Type (estandar/normal/emergencia)');
                          if(!getValue(fImpact))   missing.push('Impact');
                          if(!getValue(fPlan))     missing.push('Implementation Plan');
                          if(!getValue(fRollback)) missing.push('RollBack Planning');
                          if(!getValue(fPruebas))  missing.push('Test Planning');
                          if(!getValue(fAprob))    missing.push('Approvers');
                          if(!getValue(fStart))    missing.push('Start date (YYYY-MM-DD)');
                          if(!getValue(fTarget))   missing.push('Target date (YYYY-MM-DD)');

                          core.setOutput('has_missing_fields', missing.length > 0 ? 'true' : 'false');
                          core.setOutput('missing_fields', JSON.stringify(missing));
                          core.setOutput('project_id', projectId);
                          core.setOutput('item_id', itemId);
                          core.setOutput('project_url', userProjUrl);

      - name: Add CCC Form if Missing Fields
        if: steps.check_fields.outputs.has_missing_fields == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const issue = context.payload.issue;
            const missing = JSON.parse('${{ steps.check_fields.outputs.missing_fields }}');
            const projectUrl = '${{ steps.check_fields.outputs.project_url }}';
            
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number
            });
            
            const hasForm = comments.data.some(c => c.body.includes('Formulario de Control de Cambios (CCC)'));
            
            if (hasForm) {
              console.log('El formulario CCC ya existe');
              return;
            }
            
            const list = missing.map(m => `- [ ] \`${m}\``).join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `## üìã Formulario de Control de Cambios (CCC)

            > ‚ö†Ô∏è **Aprobaci√≥n pendiente - Informaci√≥n requerida**
            > 
            > Para completar la aprobaci√≥n, necesitas llenar los siguientes campos **directamente en el proyecto**.

            ---

            ### ‚ùå Campos faltantes en el proyecto:

            ${list}

            ---

            ### üìù C√≥mo completar la informaci√≥n

            **Opci√≥n 1: Llenar en el proyecto (Recomendado)**

            1. **[Haz clic aqu√≠ para ir al Proyecto ‚Üí](${projectUrl})**
            2. Busca esta tarjeta (Issue #${issue.number})
            3. Llena los campos indicados arriba haciendo clic en cada celda
            4. Vuelve a este issue y **comenta** \`/verificar\` para validar

            **Opci√≥n 2: Responder en este issue**

            Tambi√©n puedes completar la informaci√≥n directamente aqu√≠. Copia y llena la siguiente plantilla:

            <details>
            <summary><b>üìã Plantilla de informaci√≥n CCC</b> (Click para expandir)</summary>

            \`\`\`
            ### Change Type
            Tipo de cambio: [ ] estandar [ ] normal [ ] emergencia

            ### Impact
            Describe el impacto del cambio:
            - Usuarios afectados: 
            - Sistemas impactados: 
            - Nivel de criticidad: [ ] Bajo [ ] Medio [ ] Alto

            ### Implementation Plan
            Pasos detallados de implementaci√≥n:
            1. 
            2. 
            3. 

            Recursos necesarios:
            - Personal: @
            - Tiempo estimado: ___ horas
            - Ventana de mantenimiento: [ ] S√≠ [ ] No

            ### RollBack Planning
            Procedimiento de rollback:
            1. 
            2. 
            3. 

            Tiempo estimado de rollback: ___ minutos
            ¬øEs completamente reversible? [ ] S√≠ [ ] No

            ### Test Planning
            Estrategia de testing:
            - Tests unitarios: [ ] Completos
            - Tests de integraci√≥n: [ ] Completos
            - Tests E2E: [ ] Completos

            Casos de prueba cr√≠ticos:
            1. 
            2. 

            ### Approvers
            Aprobadores requeridos:
            - [ ] Tech Lead: @
            - [ ] Product Owner: @
            - [ ] DevOps: @
            - [ ] Otro: @

            ### Start date
            Fecha de inicio (YYYY-MM-DD): 

            ### Target date
            Fecha objetivo (YYYY-MM-DD): 
            \`\`\`

            **Una vez completado**, comenta: \`/actualizar\` para sincronizar con el proyecto

            </details>

            ---

            ### ‚úÖ Comandos disponibles

            - \`/verificar\` - Verificar si ya se completaron los campos en el proyecto
            - \`/actualizar\` - Actualizar el proyecto con la informaci√≥n de este issue
            - \`/ayuda\` - Mostrar ayuda sobre c√≥mo llenar cada campo

            ---

            _ü§ñ Este formulario fue generado autom√°ticamente. La etiqueta "approved" se removi√≥ temporalmente hasta completar la informaci√≥n._`
                        });

      - name: Revert Status and Remove Label
        if: steps.check_fields.outputs.has_missing_fields == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const projectId = '${{ steps.check_fields.outputs.project_id }}';
            const itemId = '${{ steps.check_fields.outputs.item_id }}';
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();
            
            const fields = await github.graphql(
              `query($projectId:ID!){
                node(id:$projectId){
                  ... on ProjectV2 {
                    fields(first:50){
                      nodes{
                        ... on ProjectV2FieldCommon { id name }
                        ... on ProjectV2SingleSelectField { id name options{ id name } }
                      }
                    }
                  }
                }
              }`,
              { projectId }
            );
            
            const fStatusCcc = fields.node.fields.nodes.find(f => {
              const fn = norm(f?.name);
              return fn === 'status_ccc' || fn === 'status ccc' || fn.includes('status_ccc');
            });
            
            if (fStatusCcc) {
              const opts = fStatusCcc.options || [];
              const inbox = opts.find(o => norm(o.name) === 'inbox') || opts.find(o => norm(o.name).includes('inbox'));
              
              if (inbox) {
                await github.graphql(
                  `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                    updateProjectV2ItemFieldValue(input:{
                      projectId:$projectId,
                      itemId:$itemId,
                      fieldId:$fieldId,
                      value:{ singleSelectOptionId:$opt }
                    }){
                      clientMutationId
                    }
                  }`,
                  { projectId, itemId, fieldId: fStatusCcc.id, opt: inbox.id }
                );
              }
            }
            
            try {
              const labelName = context.payload.label.name;
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                name: labelName
              });
            } catch(e) {
              console.log('No se pudo remover el label:', e.message);
            }

      - name: Approve if Complete
        if: steps.check_fields.outputs.has_missing_fields == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const projectId = '${{ steps.check_fields.outputs.project_id }}';
            const itemId = '${{ steps.check_fields.outputs.item_id }}';
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();

            async function setSelect(field,optName){
              if(!field || !optName) return false;
              const opts = field.options || [];
              const normalizedOptName = norm(optName);
              const wanted = opts.find(o=>norm(o.name)===normalizedOptName) || opts.find(o=>norm(o.name).includes(normalizedOptName));
              if(!wanted) {
                console.log(`Opci√≥n "${normalizedOptName}" no encontrada para el campo "${field.name}"`);
                return false;
              }
              await github.graphql(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ singleSelectOptionId:$opt }
                  }){
                    clientMutationId
                  }
                }`,
                { projectId, itemId, fieldId: field.id, opt: wanted.id }
              );
              return true;
            }

            const fields = await github.graphql(
              `query($projectId:ID!){
                node(id:$projectId){
                  ... on ProjectV2 {
                    fields(first:50){
                      nodes{
                        ... on ProjectV2FieldCommon { id name }
                        ... on ProjectV2SingleSelectField { id name options{ id name } }
                      }
                    }
                  }
                }
              }`,
              { projectId }
            );
            
            const allFields = fields.node.fields.nodes;
            
            const fStatusCcc = allFields.find(f => {
              const fn = norm(f?.name);
              return fn === 'status_ccc' || fn === 'status ccc' || fn.includes('status_ccc');
            });
            
            const fStatus = allFields.find(f => norm(f?.name) === 'status');
            
            await setSelect(fStatusCcc, 'Approved');
            await setSelect(fStatus, 'Ready');
            
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                name: 'denied'
              });
            } catch(e) {}
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: `## ‚úÖ Aprobaci√≥n Completada

              Todos los campos requeridos est√°n completos. El cambio ha sido aprobado exitosamente.

              **Estado actualizado:** Ready
              **Estado CCC:** Approved
              **Fecha:** ${new Date().toISOString().slice(0, 19).replace('T', ' ')}

              Puedes proceder con la implementaci√≥n seg√∫n el plan establecido.`
                          });

  # --- Job: process-rfc-approval (Solo para 'rfc' sin 'user') ---
  process-rfc-approval:
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'labeled' &&
      (github.event.label.name == 'approved' ||
        github.event.label.name == 'Approved' ||
        github.event.label.name == 'aprobado' ||
        github.event.label.name == 'Aprobado') &&
      contains(github.event.issue.labels.*.name, 'rfc') &&
      !contains(github.event.issue.labels.*.name, 'user')
    runs-on: ubuntu-latest
    steps:
      - name: Set Status to Ready and Approved
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const issue = context.payload.issue;
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();

            const actor = context.actor;
            const ORG_LOGIN  = process.env.ORG_LOGIN;

            let isCccMember = false;
            if (ORG_LOGIN) {
              try {
                await github.rest.teams.getMembershipForUserInOrg({
                  org: ORG_LOGIN,
                  team_slug: 'ccc',
                  username: actor
                });
                isCccMember = true;
              } catch (error) {
                if (error.status === 404) {
                  isCccMember = false;
                } else {
                  console.log(`Error al verificar membres√≠a: ${error.message}`);
                  isCccMember = false;
                }
              }
            }

            if (!isCccMember) {
              console.log(`Usuario ${actor} no pertenece al equipo "ccc". Acceso denegado.`);
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                name: context.payload.label.name
              }).catch(() => {});
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `## ‚õî Permiso Denegado

              @${actor}, no tienes permisos para aprobar cambios. Solo los miembros del equipo **ccc** pueden aprobar o denegar solicitudes.`
                            });
                            return;
                          }

                          const USER_LOGIN = process.env.USER_LOGIN;
                          const PN_MAIN    = parseInt(process.env.PROJECT_NUMBER,10);
                          
                          async function getUserProjByNum(n){
                            const r = await github.graphql(
                              `query($login:String!){
                                user(login:$login){
                                  projectsV2(first:50){
                                    nodes{ id number }
                                  }
                                }
                              }`,
                              { login: USER_LOGIN }
                            ).catch(()=>null);
                            return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
                          }

                          async function getOrgProjByNum(n){
                            if(!ORG_LOGIN) return null;
                            const r = await github.graphql(
                              `query($login:String!){
                                organization(login:$login){
                                  projectsV2(first:50){
                                    nodes{ id number }
                                  }
                                }
                              }`,
                              { login: ORG_LOGIN }
                            ).catch(()=>null);
                            return r?.organization?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
                          }
                          
                          async function findItemId(projectId, issueNumber){
                            const r = await github.graphql(
                              `query($projectId:ID!, $q:String!){
                                node(id:$projectId){
                                  ... on ProjectV2 {
                                    items(first:50, query:$q){
                                      nodes{
                                        id
                                        content{ ... on Issue { number } }
                                      }
                                    }
                                  }
                                }
                              }`,
                              { projectId, q: String(issueNumber) }
                            );
                            return r?.node?.items?.nodes?.find(n=>n.content?.number===issueNumber)?.id || null;
                          }

                          async function setSelect(projectId, itemId, field, optName){
                            if(!field || !optName) return false;
                            const opts = field.options || [];
                            const normalizedOptName = norm(optName);
                            const wanted = opts.find(o=>norm(o.name)===normalizedOptName) || opts.find(o=>norm(o.name).includes(normalizedOptName));
                            if(!wanted) {
                              console.log(`Opci√≥n "${normalizedOptName}" no encontrada para el campo "${field.name}"`);
                              return false;
                            }
                            await github.graphql(
                              `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                                updateProjectV2ItemFieldValue(input:{
                                  projectId:$projectId,
                                  itemId:$itemId,
                                  fieldId:$fieldId,
                                  value:{ singleSelectOptionId:$opt }
                                }){
                                  clientMutationId
                                }
                              }`,
                              { projectId, itemId, fieldId: field.id, opt: wanted.id }
                            );
                            return true;
                          }
                          
                          const projectId = await getUserProjByNum(PN_MAIN) || await getOrgProjByNum(PN_MAIN);
                          if (!projectId) {
                            console.log('Proyecto principal no encontrado.');
                            return;
                          }
                          
                          const itemId = await findItemId(projectId, issue.number);
                          if (!itemId) {
                            console.log('Item no encontrado en el proyecto principal.');
                            return;
                          }
                          
                          if (issue.state === 'closed') {
                            console.log('El issue estaba cerrado. Reabriendo.');
                            await github.rest.issues.update({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: issue.number,
                              state: 'open'
                            });
                          }

                          const fields = await github.graphql(
                            `query($projectId:ID!){
                              node(id:$projectId){
                                ... on ProjectV2 {
                                  fields(first:50){
                                    nodes{
                                      ... on ProjectV2FieldCommon { id name }
                                      ... on ProjectV2SingleSelectField { id name options{ id name } }
                                    }
                                  }
                                }
                              }
                            }`,
                            { projectId }
                          );
                          
                          const allFields = fields.node.fields.nodes;
                          const fStatusCcc = allFields.find(f => norm(f?.name) === 'status_ccc');
                          const fStatus = allFields.find(f => norm(f?.name) === 'status');
                          
                          await setSelect(projectId, itemId, fStatusCcc, 'Approved');
                          await setSelect(projectId, itemId, fStatus, 'Ready');
                          
                          try {
                            await github.rest.issues.removeLabel({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: context.payload.issue.number,
                              name: 'denied'
                            });
                          } catch(e) {}
                          
                          await github.rest.issues.createComment({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: issue.number,
                            body: `## ‚úÖ RFC Aprobado

              El RFC ha sido aprobado.

              **Estado actualizado:** Ready
              **Estado CCC:** Approved
              **Fecha:** ${new Date().toISOString().slice(0, 19).replace('T', ' ')}`)
            });

  # --- Job: process-denial (para 'rfc' y 'user') ---
  process-denial:
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'labeled' &&
      (github.event.label.name == 'denied' ||
       github.event.label.name == 'Denegado' ||
       github.event.label.name == 'denegado')
    runs-on: ubuntu-latest
    steps:
      - name: Set Status to Not Planned and Denied
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const issue = context.payload.issue;
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();

            const actor = context.actor;
            const ORG_LOGIN  = process.env.ORG_LOGIN;

            let isCccMember = false;
            if (ORG_LOGIN) {
              try {
                await github.rest.teams.getMembershipForUserInOrg({
                  org: ORG_LOGIN,
                  team_slug: 'ccc',
                  username: actor
                });
                isCccMember = true;
              } catch (error) {
                if (error.status === 404) {
                  isCccMember = false;
                } else {
                  console.log(`Error al verificar membres√≠a: ${error.message}`);
                  isCccMember = false;
                }
              }
            }

            if (!isCccMember) {
              console.log(`Usuario ${actor} no pertenece al equipo "ccc". Acceso denegado.`);
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                name: context.payload.label.name
              }).catch(() => {});
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `## ‚õî Permiso Denegado

              @${actor}, no tienes permisos para denegar cambios. Solo los miembros del equipo **ccc** pueden aprobar o denegar solicitudes.`
                            });
                            return;
                          }

                          const hasRfc = (issue.labels || []).some(l => norm(l.name) === 'rfc');
                          if (!hasRfc) {
                            console.log('No es un issue RFC, saltando.');
                            return;
                          }

                          const hasUser = (issue.labels || []).some(l => norm(l.name) === 'user');

                          const USER_LOGIN = process.env.USER_LOGIN;
                          const PN_MAIN    = parseInt(process.env.PROJECT_NUMBER,10);
                          const PN_USER = parseInt(process.env.PROJECT_NUMBER_USER || '0', 10);
                          
                          async function getUserProjByNum(n){
                            const r = await github.graphql(
                              `query($login:String!){
                                user(login:$login){
                                  projectsV2(first:50){
                                    nodes{ id number }
                                  }
                                }
                              }`,
                              { login: USER_LOGIN }
                            ).catch(()=>null);
                            return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
                          }
                          
                          async function getOrgProjByNum(n){
                            if(!ORG_LOGIN) return null;
                            const r = await github.graphql(
                              `query($login:String!){
                                organization(login:$login){
                                  projectsV2(first:50){
                                    nodes{ id number }
                                  }
                                }
                              }`,
                              { login: ORG_LOGIN }
                            ).catch(()=>null);
                            return r?.organization?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
                          }

                          async function findItemId(projectId, issueNumber){
                            const r = await github.graphql(
                              `query($projectId:ID!, $q:String!){
                                node(id:$projectId){
                                  ... on ProjectV2 {
                                    items(first:50, query:$q){
                                      nodes{
                                        id
                                        content{ ... on Issue { number } }
                                      }
                                    }
                                  }
                                }
                              }`,
                              { projectId, q: String(issueNumber) }
                            );
                            return r?.node?.items?.nodes?.find(n=>n.content?.number===issueNumber)?.id || null;
                          }
                          
                          let projectId = null;
                          if (hasUser) {
                            projectId = await getUserProjByNum(PN_USER);
                          } else {
                            projectId = await getUserProjByNum(PN_MAIN) || await getOrgProjByNum(PN_MAIN);
                          }

                          if (!projectId) {
                            console.log('Proyecto (user o main) no encontrado.');
                            return;
                          }
                          
                          const itemId = await findItemId(projectId, issue.number);
                          if (!itemId) {
                            console.log('Item no encontrado en el proyecto.');
                            return;
                          }

                          if (issue.state === 'open') {
                            console.log('El issue est√° abierto. Cerrando como "not_planned".');
                            await github.rest.issues.update({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: issue.number,
                              state: 'closed',
                              state_reason: 'not_planned'
                            });
                          }

                          async function setSelect(field,optName){
                            if(!field || !optName) return false;
                            const opts = field.options || [];
                            const normalizedOptName = norm(optName);
                            const wanted = opts.find(o=>norm(o.name)===normalizedOptName) || opts.find(o=>norm(o.name).includes(normalizedOptName));
                            if(!wanted) {
                              console.log(`Opci√≥n "${normalizedOptName}" no encontrada para el campo "${field.name}"`);
                              return false;
                            }
                            await github.graphql(
                              `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                                updateProjectV2ItemFieldValue(input:{
                                  projectId:$projectId,
                                  itemId:$itemId,
                                  fieldId:$fieldId,
                                  value:{ singleSelectOptionId:$opt }
                                }){
                                  clientMutationId
                                }
                              }`,
                              { projectId, itemId, fieldId: field.id, opt: wanted.id }
                            );
                            return true;
                          }

                          const fields = await github.graphql(
                            `query($projectId:ID!){
                              node(id:$projectId){
                                ... on ProjectV2 {
                                  fields(first:50){
                                    nodes{
                                      ... on ProjectV2FieldCommon { id name }
                                      ... on ProjectV2SingleSelectField { id name options{ id name } }
                                    }
                                  }
                                }
                              }
                            }`,
                            { projectId }
                          );
                          
                          const allFields = fields.node.fields.nodes;
                          
                          const fStatusCcc = allFields.find(f => {
                            const fn = norm(f?.name);
                            return fn === 'status_ccc' || fn === 'status ccc' || fn.includes('status_ccc');
                          });
                          
                          const fStatus = allFields.find(f => norm(f?.name) === 'status');
                          
                          await setSelect(fStatusCcc, 'Denied');
                          await setSelect(fStatus, 'Not Planned');
                          
                          try {
                            await github.rest.issues.removeLabel({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: context.payload.issue.number,
                              name: 'approved'
                            });
                          } catch(e) {}
                          
                          await github.rest.issues.createComment({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: issue.number,
                            body: `## ‚ùå Solicitud Denegada

              El issue ha sido marcado como denegado y cerrado.

              **Estado actualizado:** Not Planned
              **Estado CCC:** Denied`
                          });

  # --- Job: process-pr-link (bloquea PRs a main sin RFC correcto) ---
  process-pr-link:
    if: github.event_name == 'pull_request' && (github.event.action == 'opened' || github.event.action == 'edited' || github.event.action == 'synchronize') && github.base_ref == 'main'
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR for RFC Process
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const pr = context.payload.pull_request;
            const prBody = pr.body || '';
            const prTitle = pr.title || '';
            const prNumber = pr.number;
            const content = prBody + ' ' + prTitle;
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();
            
            const allIssuesRegex = /#(\d+)/gi;
            const closingRegex = /(?:closes|fixes|resolves) #(\d+)/gi;
            
            let match;
            const allIssueNumbers = new Set();
            const closingNumbers = new Set();
            
            while ((match = allIssuesRegex.exec(content)) !== null) {
              allIssueNumbers.add(match[1]);
            }
            while ((match = closingRegex.exec(content)) !== null) {
              closingNumbers.add(match[1]);
            }
            
            if (allIssueNumbers.size === 0) {
              console.log('PR no linkea a ningun issue. Pasando.');
              return;
            }
            
            const USER_LOGIN = process.env.USER_LOGIN;
            const ORG_LOGIN  = process.env.ORG_LOGIN;
            const PN_MAIN    = parseInt(process.env.PROJECT_NUMBER,10);
            const PN_USER    = parseInt(process.env.PROJECT_NUMBER_USER||'0',10);
            
            async function getUserProjByNum(n){
              const r = await github.graphql(
                `query($login:String!){
                  user(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: USER_LOGIN }
              ).catch(()=>null);
              return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }

            async function getOrgProjByNum(n){
              if(!ORG_LOGIN) return null;
              const r = await github.graphql(
                `query($login:String!){
                  organization(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: ORG_LOGIN }
              ).catch(()=>null);
              return r?.organization?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }
            
            async function findItemId(projectId, issueNumber){
              const r = await github.graphql(
                `query($projectId:ID!, $q:String!){
                  node(id:$projectId){
                    ... on ProjectV2 {
                      items(first:50, query:$q){
                        nodes{
                          id
                          content{ ... on Issue { number } }
                        }
                      }
                    }
                  }
                }`,
                { projectId, q: String(issueNumber) }
              );
              return r?.node?.items?.nodes?.find(n=>n.content?.number===parseInt(issueNumber,10))?.id || null;
            }

            async function getFields(projectId){
              const r = await github.graphql(
                `query($projectId:ID!){
                  node(id:$projectId){
                    ... on ProjectV2 {
                      fields(first:100){
                        nodes{
                          ... on ProjectV2FieldCommon { id name dataType }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                        }
                      }
                    }
                  }
                }`,
                { projectId }
              );
              return r?.node?.fields?.nodes || [];
            }

            async function setSelect(projectId, itemId, field, optName){
              if(!field || !optName) return false;
              const opts = field.options || [];
              const normalizedOptName = norm(optName);
              const wanted = opts.find(o=>norm(o.name)===normalizedOptName) || opts.find(o=>norm(o.name).includes(normalizedOptName));
              if(!wanted) {
                console.log(`Opci√≥n "${normalizedOptName}" no encontrada para el campo "${field.name}"`);
                return false;
              }
              await github.graphql(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ singleSelectOptionId:$opt }
                  }){
                    clientMutationId
                  }
                }`,
                { projectId, itemId, fieldId: field.id, opt: wanted.id }
              );
              return true;
            }
            
            const prComments = new Map();
            let didFail = false;
            let hasOpenRfc = false;

            for (const issueNum of allIssueNumbers) {
              console.log(`Procesando issue #${issueNum}`);
              
              let issue;
              try {
                issue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum
                });
              } catch (e) {
                console.log(`No se pudo obtener issue #${issueNum}: ${e.message}`);
                continue;
              }
              
              const hasRfc = (issue.data.labels || []).some(l => norm(l.name) === 'rfc');
              if (!hasRfc) {
                console.log(`Issue #${issueNum} no es 'rfc'. Saltando.`);
                continue;
              }
              
              if (issue.data.state !== 'open') {
                console.log(`Issue #${issueNum} ya est√° cerrado. Verificando motivo...`);
                
                const hasDeniedLabel = (issue.data.labels || []).some(l => norm(l.name) === 'denied');
                const reason = issue.data.state_reason;
                let commentBody = '';

                if (hasDeniedLabel) {
                  commentBody = `‚ö†Ô∏è **Referencia a Issue Denegado:** El Issue #${issueNum} (referenciado en este PR) fue denegado y est√° cerrado.`;
                } else if (reason === 'not_planned') {
                  commentBody = `‚ÑπÔ∏è **Referencia a Issue No Planeado:** El Issue #${issueNum} (referenciado en este PR) est√° cerrado como "No Planeado".`;
                } else if (reason === 'completed') {
                  commentBody = `‚úÖ **Referencia a Issue Completado:** El Issue #${issueNum} (referenciado en este PR) ya fue completado.`;
                }
                
                if (commentBody && !prComments.has(commentBody)) {
                  prComments.set(commentBody, true);
                }
                
                continue;
              }
              
              hasOpenRfc = true; 
              
              if (!closingNumbers.has(issueNum)) {
                const commentBody = `‚ùå **ACCI√ìN REQUERIDA:** El Issue RFC #${issueNum} est√° abierto y debe cerrarse con este PR.

              Por favor, edita la descripci√≥n de este PR y a√±ade una palabra clave como \`closes #${issueNum}\`, \`fixes #${issueNum}\`, o \`resolves #${issueNum}\` para continuar.`;
                              if (!prComments.has(commentBody)) {
                                prComments.set(commentBody, true);
                                core.setFailed(`El Issue RFC #${issueNum} debe tener una palabra clave de cierre.`);
                                didFail = true;
                              }
                              continue;
                            }
                            
                            const hasUser = (issue.data.labels || []).some(l => norm(l.name) === 'user');
                            
                            let projectId = null;
                            if (hasUser) {
                              projectId = await getUserProjByNum(PN_USER);
                            } else {
                              projectId = await getUserProjByNum(PN_MAIN) || await getOrgProjByNum(PN_MAIN);
                            }
                            
                            if(!projectId) {
                              console.log(`No se pudo encontrar proyecto para issue #${issueNum}.`);
                              continue;
                            }

                            const itemId = await findItemId(projectId, issueNum);
                            if (!itemId) {
                              console.log(`Issue #${issueNum} no es un item en el proyecto.`);
                              continue;
                            }

                            const allFields = await getFields(projectId);
                            const fStatus = allFields.find(f => norm(f?.name) === 'status');
                            
                            if (!fStatus) {
                              console.log(`Campo "Status" no encontrado en el proyecto para #${issueNum}.`);
                              continue;
                            }
              
              const success = await setSelect(projectId, itemId, fStatus, 'In Review');
              
              if (success) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum,
                  body: `## üîÑ En Revisi√≥n

              El estado ha sido actualizado a \`In Review\` debido al Pull Request #${prNumber}.`
                              });
                            }
                          }
                                      
                          if (prComments.size > 0) {
                            const finalComment = Array.from(prComments.keys()).join('\n\n---\n');
                            await github.rest.issues.createComment({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: prNumber,
                              body: finalComment
                            });
                          }

                          if (didFail) {
                            core.setFailed('Este PR no cumple con las reglas de vinculaci√≥n de issues RFC. Revisa los comentarios del bot.');
                            return;
                          }
                          
                          if (hasOpenRfc) {
                            console.log('Todos los RFCs abiertos fueron procesados. Job exitoso.');
                          } else {
                            console.log('PR no linkea a ning√∫n RFC abierto. Pasando.');
            }

  # --- Job: process-pr-closed (PR Rechazado) ---
  process-pr-closed:
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.base_ref == 'main' && github.event.pull_request.merged == false
    runs-on: ubuntu-latest
    steps:
      - name: Set Issue Status to In Progress
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const pr = context.payload.pull_request;
            const prBody = pr.body || '';
            const prTitle = pr.title || '';
            const prNumber = pr.number;
            const content = prBody + ' ' + prTitle;
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();
            
            const issueRegex = /(?:closes|fixes|resolves) #(\d+)|#(\d+)/gi;
            let match;
            const issueNumbers = new Set();
            
            while ((match = issueRegex.exec(content)) !== null) {
              issueNumbers.add(match[1] || match[2]);
            }
            
            if (issueNumbers.size === 0) {
              console.log('PR no linkea a ningun issue.');
              return;
            }
            
            const USER_LOGIN = process.env.USER_LOGIN;
            const ORG_LOGIN  = process.env.ORG_LOGIN;
            const PN_MAIN    = parseInt(process.env.PROJECT_NUMBER,10);
            const PN_USER    = parseInt(process.env.PROJECT_NUMBER_USER||'0',10);
            
            async function getUserProjByNum(n){
              const r = await github.graphql(
                `query($login:String!){
                  user(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: USER_LOGIN }
              ).catch(()=>null);
              return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }

            async function getOrgProjByNum(n){
              if(!ORG_LOGIN) return null;
              const r = await github.graphql(
                `query($login:String!){
                  organization(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: ORG_LOGIN }
              ).catch(()=>null);
              return r?.organization?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }
            
            async function findItemId(projectId, issueNumber){
              const r = await github.graphql(
                `query($projectId:ID!, $q:String!){
                  node(id:$projectId){
                    ... on ProjectV2 {
                      items(first:50, query:$q){
                        nodes{
                          id
                          content{ ... on Issue { number } }
                        }
                      }
                    }
                  }
                }`,
                { projectId, q: String(issueNumber) }
              );
              return r?.node?.items?.nodes?.find(n=>n.content?.number===parseInt(issueNumber,10))?.id || null;
            }
            
            async function getFields(projectId){
              const r = await github.graphql(
                `query($projectId:ID!){
                  node(id:$projectId){
                    ... on ProjectV2 {
                      fields(first:50){
                        nodes{
                          ... on ProjectV2FieldCommon { id name }
                          ... on ProjectV2SingleSelectField { id name options{ id name } }
                        }
                      }
                    }
                  }
                }`,
                { projectId }
              );
              return r?.node?.fields?.nodes || [];
            }

            async function setSelect(projectId, itemId, field, optName){
              if(!field || !optName) return false;
              const opts = field.options || [];
              const normalizedOptName = norm(optName);
              const wanted = opts.find(o=>norm(o.name)===normalizedOptName) || opts.find(o=>norm(o.name).includes(normalizedOptName));
              if(!wanted) {
                console.log(`Opci√≥n "${normalizedOptName}" no encontrada para el campo "${field.name}"`);
                return false;
              }
              await github.graphql(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ singleSelectOptionId:$opt }
                  }){
                    clientMutationId
                  }
                }`,
                { projectId, itemId, fieldId: field.id, opt: wanted.id }
              );
              return true;
            }

            for (const issueNum of issueNumbers) {
              console.log(`Procesando issue #${issueNum}`);
              
              let issue;
              try {
                issue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum
                });
              } catch (e) {
                console.log(`No se pudo obtener issue #${issueNum}: ${e.message}`);
                continue;
              }

              if (issue.data.state !== 'open') {
                console.log(`Issue #${issueNum} ya est√° cerrado. Saltando.`);
                continue;
              }
              
              const hasRfc = (issue.data.labels || []).some(l => norm(l.name) === 'rfc');
              if (!hasRfc) {
                console.log(`Issue #${issueNum} no tiene la etiqueta 'rfc'. Saltando.`);
                continue;
              }
              
              const hasUser = (issue.data.labels || []).some(l => norm(l.name) === 'user');
              
              let projectId = null;
              if (hasUser) {
                projectId = await getUserProjByNum(PN_USER);
                console.log(`Issue #${issueNum} es de 'user'. Buscando en proyecto USER.`);
              } else {
                projectId = await getUserProjByNum(PN_MAIN) || await getOrgProjByNum(PN_MAIN);
                console.log(`Issue #${issueNum} es un RFC normal. Buscando en proyecto MAIN/ORG.`);
              }
              
              if(!projectId) {
                console.log(`No se pudo encontrar un ID de proyecto (MAIN o USER) para issue #${issueNum}.`);
                continue;
              }
              
              const itemId = await findItemId(projectId, issueNum);
              if (!itemId) {
                console.log(`Issue #${issueNum} no es un item en el proyecto.`);
                continue;
              }
              
              const allFields = await getFields(projectId);
              const fStatus = allFields.find(f => norm(f?.name) === 'status');
              
              if (!fStatus) {
                console.log(`Campo "Status" no encontrado en el proyecto (ID: ${projectId}).`);
                continue;
              }
              
              const success = await setSelect(projectId, itemId, fStatus, 'In Progress');
              
              if (success) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum,
                  body: `## ‚è™ Reabierto

            El Pull Request #${prNumber} fue cerrado sin merge. El estado del issue vuelve a \`In Progress\`.`
                });
              }
            }

  # --- Job: process-pr-merged (PR Aprobado) ---
  process-pr-merged:
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.base_ref == 'main' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Close Linked Issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const pr = context.payload.pull_request;
            const prBody = pr.body || '';
            const prTitle = pr.title || '';
            const prNumber = pr.number;
            const content = prBody + ' ' + prTitle;
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();
            
            const issueRegex = /#(\d+)/gi;
            let match;
            const issueNumbers = new Set();
            
            while ((match = issueRegex.exec(content)) !== null) {
              issueNumbers.add(match[1]);
            }
            
            if (issueNumbers.size === 0) {
              console.log('PR no linkea a ningun issue.');
              return;
            }

            for (const issueNum of issueNumbers) {
              console.log(`Procesando issue #${issueNum} para cierre.`);
              
              let issue;
              try {
                issue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum
                });
              } catch (e) {
                console.log(`No se pudo obtener issue #${issueNum}: ${e.message}`);
                continue;
              }

              if (issue.data.state !== 'open') {
                console.log(`Issue #${issueNum} ya est√° cerrado. Saltando.`);
                continue;
              }
              
              const hasRfc = (issue.data.labels || []).some(l => norm(l.name) === 'rfc');
              if (!hasRfc) {
                console.log(`Issue #${issueNum} no tiene la etiqueta 'rfc'. Saltando.`);
                continue;
              }
              
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum,
                  state: 'closed',
                  state_reason: 'completed'
                });
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum,
                  body: `## ‚úÖ Completado

            El Pull Request #${prNumber} que resuelve este issue fue fusionado.

            Cerrando issue y actualizando estado del proyecto a \`Done\`.`
                            });

                          } catch (e) {
                            console.log(`No se pudo cerrar o comentar en el issue #${issueNum}: ${e.message}`);
                          }
                        }

  # --- Job: process-ccc-commands ---
  process-ccc-commands:
      if: github.event_name == 'issue_comment' && github.event.action == 'created'
      runs-on: ubuntu-latest
      steps:
        - name: Process Commands
          uses: actions/github-script@v7
          with:
            github-token: ${{ secrets.PROJECTS_PAT }}
            script: |
              const comment = context.payload.comment;
              const issue = context.payload.issue;
              const commentBody = (comment.body || '').trim();
              const actor = context.actor;

              const norm = (s) =>
                (s ?? '')
                  .toString()
                  .normalize('NFD')
                  .replace(/\p{Diacritic}/gu, '')
                  .trim()
                  .toLowerCase();

              const hasUser = (issue.labels || []).some((l) => norm(l.name) === 'user');
              if (!hasUser) {
                console.log('Issue no tiene label "user". Saltando comandos CCC.');
                return;
              }

              const USER_LOGIN = process.env.USER_LOGIN;
              const ORG_LOGIN = process.env.ORG_LOGIN;
              const PN_USER = parseInt(process.env.PROJECT_NUMBER_USER || '0', 10);

              let isCccMember = false;
              if (ORG_LOGIN) {
                try {
                  await github.rest.teams.getMembershipForUserInOrg({
                    org: ORG_LOGIN,
                    team_slug: 'ccc',
                    username: actor
                  });
                  isCccMember = true;
                } catch (error) {
                  if (error.status === 404) {
                    isCccMember = false;
                  } else {
                    console.log(`Error al verificar membres√≠a: ${error.message}`);
                    isCccMember = false;
                  }
                }
              }

              async function getUserProjByNum(n) {
                const r = await github.graphql(
                  `query($login:String!){
                    user(login:$login){
                      projectsV2(first:50){
                        nodes{ id number }
                      }
                    }
                  }`,
                  { login: USER_LOGIN }
                ).catch(() => null);
                return r?.user?.projectsV2?.nodes?.find((x) => x.number === n)?.id || null;
              }

              async function findItemId(projectId, issueNumber) {
                const r = await github.graphql(
                  `query($projectId:ID!, $q:String!){
                    node(id:$projectId){
                      ... on ProjectV2 {
                        items(first:50, query:$q){
                          nodes{
                            id
                            content{ ... on Issue { number } }
                          }
                        }
                      }
                    }
                  }`,
                  { projectId, q: String(issueNumber) }
                );
                return r.node.items.nodes.find((n) => n.content?.number === issueNumber)?.id || null;
              }

              async function getFields(projectId) {
                const r = await github.graphql(
                  `query($projectId:ID!){
                    node(id:$projectId){
                      ... on ProjectV2 {
                        fields(first:100){
                          nodes{
                            ... on ProjectV2FieldCommon { id name dataType }
                            ... on ProjectV2SingleSelectField { id name options { id name } }
                          }
                        }
                      }
                    }
                  }`,
                  { projectId }
                );
                return r.node.fields.nodes;
              }

              async function getFieldValues(itemId) {
                const r = await github.graphql(
                  `query($itemId:ID!){
                    node(id:$itemId){
                      ... on ProjectV2Item {
                        fieldValues(first:100){
                          nodes{
                            ... on ProjectV2ItemFieldTextValue {
                              text
                              field { ... on ProjectV2FieldCommon { id name } }
                            }
                            ... on ProjectV2ItemFieldDateValue {
                              date
                              field { ... on ProjectV2FieldCommon { id name } }
                            }
                            ... on ProjectV2ItemFieldSingleSelectValue {
                              name
                              optionId
                              field { ... on ProjectV2FieldCommon { id name } }
                            }
                          }
                        }
                      }
                    }
                  }`,
                  { itemId }
                );
                return r.node.fieldValues.nodes;
              }

              const by = (fields, names) =>
                names.map((n) => fields.find((f) => norm(f?.name) === norm(n))).find(Boolean);

              if (commentBody === '/verificar') {
                if (!isCccMember) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `@${actor} No tienes permisos para ejecutar este comando. Solo miembros del equipo CCC.`
                  });
                  return;
                }

                const projectId = await getUserProjByNum(PN_USER);
                if (!projectId) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: '‚ùå No se pudo encontrar el proyecto de usuario.'
                  });
                  return;
                }

                const itemId = await findItemId(projectId, issue.number);
                if (!itemId) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: '‚ùå Este issue no est√° en el proyecto.'
                  });
                  return;
                }

                const fields = await getFields(projectId);
                const fChangeType = by(fields, ['Change Type', 'Tipo de cambio']);
                const fImpact = by(fields, ['Impact']);
                const fPlan = by(fields, ['Implementation Plan']);
                const fRollback = by(fields, ['RollBack Planning', 'Rollback Plan']);
                const fPruebas = by(fields, ['Test Planning']);
                const fAprob = by(fields, ['Approvers']);
                const fStart = by(fields, ['Start date']);
                const fTarget = by(fields, ['Target date']);

                const values = await getFieldValues(itemId);
                function getValue(field) {
                  if (!field) return null;
                  const v = values.find((n) => norm(n.field?.name) === norm(field.name));
                  if (!v) return null;
                  if ('text' in v) return (v.text || '').trim();
                  if ('date' in v) return (v.date || '').trim();
                  if ('name' in v) return (v.name || '').trim();
                  return null;
                }

                const missing = [];
                if (!getValue(fChangeType)) missing.push('Change Type');
                if (!getValue(fImpact)) missing.push('Impact');
                if (!getValue(fPlan)) missing.push('Implementation Plan');
                if (!getValue(fRollback)) missing.push('RollBack Planning');
                if (!getValue(fPruebas)) missing.push('Test Planning');
                if (!getValue(fAprob)) missing.push('Approvers');
                if (!getValue(fStart)) missing.push('Start date');
                if (!getValue(fTarget)) missing.push('Target date');

                if (missing.length > 0) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `## ‚ùå Campos a√∫n incompletos

              Faltan los siguientes campos en el proyecto:
              ${missing.map((m) => `- \`${m}\``).join('\n')}

              Por favor, completa estos campos en el proyecto y vuelve a ejecutar \`/verificar\`.`
                  });
                } else {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `## ‚úÖ Verificaci√≥n Exitosa

              Todos los campos requeridos est√°n completos. Ahora puedes agregar la etiqueta \`approved\` para aprobar el cambio.`
                  });
                }
                return;
              }

              if (commentBody === '/ayuda') {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `## üìñ Ayuda - Formulario CCC

              ### Comandos disponibles:
              - \`/verificar\` - Verifica si todos los campos est√°n completos en el proyecto
              - \`/actualizar\` - Actualiza el proyecto con informaci√≥n de este issue
              - \`/ayuda\` - Muestra esta ayuda

              ### Gu√≠a de campos requeridos:

              **Change Type**: Tipo de cambio
              - \`estandar\`: Cambio pre-aprobado, bajo riesgo
              - \`normal\`: Cambio que requiere evaluaci√≥n est√°ndar
              - \`emergencia\`: Cambio urgente para resolver un incidente

              **Impact**: Describe el impacto del cambio
              - Usuarios afectados
              - Sistemas impactados
              - Nivel de criticidad

              **Implementation Plan**: Pasos detallados para implementar
              - Lista numerada de pasos
              - Recursos necesarios
              - Tiempo estimado

              **RollBack Planning**: Plan de reversi√≥n
              - Procedimiento paso a paso para revertir
              - Tiempo estimado de rollback
              - Indicar si es completamente reversible

              **Test Planning**: Estrategia de pruebas
              - Tipos de tests a ejecutar
              - Casos de prueba cr√≠ticos
              - Criterios de aceptaci√≥n

              **Approvers**: Personas que deben aprobar
              - Lista de @usuarios requeridos
              - Tech Lead, Product Owner, DevOps, etc.

              **Start date**: Fecha de inicio (formato: YYYY-MM-DD)
              **Target date**: Fecha objetivo (formato: YYYY-MM-DD)`
                });
                return;
              }

              if (commentBody === '/actualizar') {
                if (!isCccMember) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `@${actor} No tienes permisos para ejecutar este comando. Solo miembros del equipo CCC.`
                  });
                  return;
                }

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `## üîÑ Actualizaci√≥n del Proyecto

              El comando \`/actualizar\` permite sincronizar informaci√≥n desde este issue hacia el proyecto.

              **Pr√≥ximamente disponible**: Esta funcionalidad est√° en desarrollo.

              Por ahora, por favor actualiza los campos manualmente en el proyecto y usa \`/verificar\` para confirmar.`
                });
                return;
              }

  

  # --- Job: set-project-status-on-close ---
  set-project-status-on-close:
    if: github.event_name == 'issues' && github.event.action == 'closed'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const issue = context.payload.issue;
            const hasUser = (issue.labels || []).some(
              (l) => (l.name || '').toLowerCase() === 'user'
            );

            const USER_LOGIN = process.env.USER_LOGIN;
            const ORG_LOGIN  = process.env.ORG_LOGIN;
            const PN_MAIN    = parseInt(process.env.PROJECT_NUMBER,10);
            const PN_USER    = parseInt(process.env.PROJECT_NUMBER_USER||'0',10);

            async function getUserProjByNum(n){
              const r = await github.graphql(
                `query($login:String!){
                  user(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: USER_LOGIN }
              ).catch(()=>null);
              return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }
            async function getOrgProjByNum(n){
              if(!ORG_LOGIN) return null;
              const r = await github.graphql(
                `query($login:String!){
                  organization(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: ORG_LOGIN }
              ).catch(()=>null);
              return r?.organization?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }

            let projectId = null;
            if (hasUser) {
              projectId = await getUserProjByNum(PN_USER);
            } else {
              projectId = await getUserProjByNum(PN_MAIN) || await getOrgProjByNum(PN_MAIN);
            }
            if(!projectId) return;

            const issueNum = issue.number;
            const items = await github.graphql(
              `query($projectId:ID!, $q:String!){
                node(id:$projectId){
                  ... on ProjectV2 {
                    items(first:50, query:$q){
                      nodes{
                        id
                        content{ ... on Issue { number } }
                      }
                    }
                  }
                }
              }`,
              { projectId, q: String(issueNum) }
            );
            const item = items.node.items.nodes.find(n=>n.content?.number===issueNum);
            if(!item) return;

            const fields = await github.graphql(
              `query($projectId:ID!){
                node(id:$projectId){
                  ... on ProjectV2 {
                    fields(first:50){
                      nodes{
                        ... on ProjectV2FieldCommon { id name }
                        ... on ProjectV2SingleSelectField { id name options{ id name } }
                      }
                    }
                  }
                }
              }`,
              { projectId }
            );
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();
            const status = fields.node.fields.nodes.find(f=>norm(f.name)==='status');
            if(!status) return;

            const reason = context.payload.issue.state_reason;
            let optionName = 'Done';
            if (reason !== 'completed') {
               optionName = 'Not Planned';
            }

            const opt = (status.options||[]).find(o=>norm(o.name)===norm(optionName) || norm(o.name)==='no planeado' || norm(o.name)==='done');
            if(!opt) return;

            await github.graphql(
              `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                updateProjectV2ItemFieldValue(input:{
                  projectId:$projectId,
                  itemId:$itemId,
                  fieldId:$fieldId,
                  value:{singleSelectOptionId:$opt}
                }){
                  clientMutationId
                }
              }`,
              { projectId, itemId: item.id, fieldId: status.id, opt: opt.id }
            );

  # --- Job: remove-project-item-on-delete ---
  remove-project-item-on-delete:
    if: github.event_name == 'issues' && github.event.action == 'deleted'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const issue = context.payload.issue;
            const hasUser = (issue.labels || []).some(
              (l) => (l.name || '').toLowerCase() === 'user'
            );

            const USER_LOGIN = process.env.USER_LOGIN;
            const ORG_LOGIN  = process.env.ORG_LOGIN;
            const PN_MAIN    = parseInt(process.env.PROJECT_NUMBER,10);
            const PN_USER    = parseInt(process.env.PROJECT_NUMBER_USER||'0',10);

            async function getUserProjByNum(n){
              const r = await github.graphql(
                `query($login:String!){
                  user(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: USER_LOGIN }
              ).catch(()=>null);
              return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }
            async function getOrgProjByNum(n){
              if(!ORG_LOGIN) return null;
              const r = await github.graphql(
                `query($login:String!){
                  organization(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: ORG_LOGIN }
              ).catch(()=>null);
              return r?.organization?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }

            let projectId = null;
            if (hasUser) {
              projectId = await getUserProjByNum(PN_USER);
            } else {
              projectId = await getUserProjByNum(PN_MAIN) || await getOrgProjByNum(PN_MAIN);
            }
            if(!projectId) return;

            const items = await github.graphql(
              `query($projectId:ID!, $q:String!){
                node(id:$projectId){
                  ... on ProjectV2 {
                    items(first:50, query:$q){
                      nodes{
                        id
                        content{ ... on Issue { number } }
                      }
                    }
                  }
                }
              }`,
              { projectId, q: String(issue.number) }
            );
            const item = items.node.items.nodes.find(n=>n.content?.number===issue.number);
            if(!item) return;

            await github.graphql(
              `mutation($projectId:ID!, $itemId:ID!){
                deleteProjectV2Item(input:{
                  projectId:$projectId,
                  itemId:$itemId
                }){
                  clientMutationId
                }
              }`,
              { projectId, itemId: item.id }
            );
