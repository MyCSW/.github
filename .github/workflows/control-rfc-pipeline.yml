name: RFC Controller

on:
  issues:
    types: [opened, edited, labeled, closed, deleted]
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, edited, synchronize, closed]

concurrency:
  group: rfc-${{ github.event.issue.number }}-${{ github.event.action }}
  cancel-in-progress: false

permissions:
  contents: read
  issues: write
  repository-projects: write
  pull-requests: read

env:
  PROJECT_URL: https://github.com/orgs/MyCSW/projects/2
  ORG_LOGIN: MyCSW
  USER_LOGIN: ErickGuerron
  PROJECT_NUMBER: 2
  PROJECT_TITLE: Formularios-Develops-ORG
  PROJECT_NUMBER_USER: 3
  PROJECT_TITLE_USER: Formularios-Usuario_Final-ORG

jobs:
  # --- Job: process_rfc_on_github ---
# --- Job: process_rfc_on_github ---
  process_rfc_on_github:
    if: |
      github.event_name == 'issues' &&
      (github.event.action == 'opened' || github.event.action == 'edited' || github.event.action == 'closed')
    runs-on: ubuntu-latest
    steps:
      - name: Add labels, Add to Project, and Map Fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const issue = context.payload.issue;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const body = issue.body || '';
            
            // Funci√≥n para normalizar texto
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();

            function escRE(s) {
              return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            const grab = (label) => {
              const L = escRE(label);
              const variants = [
                new RegExp(`^###\\s*${L}\\s*\\n+([\\s\\S]*?)(?=\\n###|\\n$|$)`, 'im'),
                new RegExp(`\\*\\*${L}\\*\\*[\\s\\r\\n]+([\\s\\S]*?)(?=\\n\\*\\*|\\n###|\\n$|$)`, 'i'),
                new RegExp(`^${L}\\s*:\\s*(.+)$`, 'im')
              ];
              for (const re of variants) {
                const m = body.match(re);
                if (m) return m[1].trim();
              }
              return '';
            };

            const log = (msg, data = null) => {
              const timestamp = new Date().toISOString();
              console.log(`[${timestamp}] [rfc-project] ${msg}`);
              if (data) console.log(JSON.stringify(data, null, 2));
            };

            const tipo   = (grab('Tipo de cambio') || '').toLowerCase();
            const riesgo = (grab('Riesgo') || '').toLowerCase();

            const wanted = new Set(['rfc']);
            if (tipo.includes('est√°ndar') || tipo.includes('estandar')) wanted.add('tipo:estandar');
            if (tipo.includes('normal'))                                wanted.add('tipo:normal');
            if (tipo.includes('emergencia') || tipo.includes('urgente')) wanted.add('tipo:emergencia');
            if (riesgo.includes('bajo'))  wanted.add('riesgo:bajo');
            if (riesgo.includes('medio')) wanted.add('riesgo:medio');
            if (riesgo.includes('alto'))  wanted.add('riesgo:alto');

            const current = new Set((issue.labels || []).map(l => l.name));
            const toAdd = [...wanted].filter(l => !current.has(l));
            
            if (toAdd.length) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: issue.number,
                labels: toAdd
              });
            }

            const hasUserLabel = (issue.labels || []).some(
              (l) => norm(l.name) === 'user'
            );

            const ORG_LOGIN  = (process.env.ORG_LOGIN || '').trim();
            const USER_LOGIN = (process.env.USER_LOGIN || context.repo.owner).trim();
            const PROJECT_NUMBER       = parseInt(process.env.PROJECT_NUMBER || '0', 10);
            const PROJECT_TITLE        = (process.env.PROJECT_TITLE || '').trim();
            const PROJECT_NUMBER_USER  = parseInt(process.env.PROJECT_NUMBER_USER || '0', 10);
            const PROJECT_TITLE_USER   = (process.env.PROJECT_TITLE_USER || '').trim();
            const PROJECT_URL          = (process.env.PROJECT_URL || '').trim();

            log(`üìã Configuraci√≥n detectada: ORG=${ORG_LOGIN}, USER=${USER_LOGIN}, Issue=#${issue.number}`);

            // --- Funciones de Resoluci√≥n de Proyecto ---
            async function resolveFromUrl(url){
              if (!url) return null;
              let mu = url.match(/https:\/\/github\.com\/users\/([^/]+)\/projects\/(\d+)/i);
              if (mu) {
                const login = mu[1];
                const num   = parseInt(mu[2],10);
                const r = await github.graphql(`query($login:String!){ user(login:$login){ projectsV2(first:20){ nodes{ id number title } } } }`, { login }).catch(()=>null);
                return r?.user?.projectsV2?.nodes?.find(n => n.number === num)?.id;
              }
              mu = url.match(/https:\/\/github\.com\/orgs\/([^/]+)\/projects\/(\d+)/i);
              if (mu) {
                const login = mu[1];
                const num   = parseInt(mu[2],10);
                const r = await github.graphql(`query($login:String!){ organization(login:$login){ projectsV2(first:20){ nodes{ id number title } } } }`, { login }).catch(()=>null);
                return r?.organization?.projectsV2?.nodes?.find(n => n.number === num)?.id;
              }
              return null;
            }

            async function resolveByUser(numberOrTitle){
              const r = await github.graphql(`query($login:String!){ user(login:$login){ projectsV2(first:20){ nodes{ id number title } } } }`, { login: USER_LOGIN }).catch(()=>null);
              const nodes = r?.user?.projectsV2?.nodes || [];
              if (typeof numberOrTitle === 'number') return nodes.find(n => n.number === numberOrTitle)?.id;
              return nodes.find(n => n.title === numberOrTitle)?.id;
            }

            async function resolveByOrg(numberOrTitle) {
              if (!ORG_LOGIN) return null;
              const r = await github.graphql(`query($login:String!){ organization(login:$login){ projectsV2(first:20){ nodes { id number title } } } }`, { login: ORG_LOGIN }).catch(()=>null);
              const nodes = r?.organization?.projectsV2?.nodes || [];
              if (typeof numberOrTitle === 'number') return nodes.find(n => n.number === numberOrTitle)?.id;
              return nodes.find(n => n.title === numberOrTitle)?.id;
            }

            async function findProjectV2Main() {
              if (PROJECT_URL) {
                const id = await resolveFromUrl(PROJECT_URL);
                if (id) return id;
              }
              if (ORG_LOGIN) {
                if (PROJECT_NUMBER > 0) {
                  const id = await resolveByOrg(PROJECT_NUMBER);
                  if (id) return id;
                }
                if (PROJECT_TITLE) {
                  const id = await resolveByOrg(PROJECT_TITLE);
                  if (id) return id;
                }
              }
              if (PROJECT_NUMBER > 0) return await resolveByUser(PROJECT_NUMBER);
              if (PROJECT_TITLE) return await resolveByUser(PROJECT_TITLE);
              return null;
            }

            async function findProjectV2User() {
              return await resolveByUser(PROJECT_NUMBER_USER) || await resolveByUser(PROJECT_TITLE_USER);
            }

            // --- Obtener Issue ID Global ---
            const issueRes = await github.graphql(
              `query($owner:String!, $name:String!, $n:Int!){ repository(owner:$owner, name:$name){ issue(number:$n){ id } } }`,
              { owner, name: repo, n: issue.number }
            );
            const issueId = issueRes.repository.issue.id;

            async function ensureItem(projectId){
              if (!projectId) return null;
              try {
                const srch = await github.graphql(
                  `query($projectId:ID!, $q:String!){ node(id:$projectId){ ... on ProjectV2 { items(first:20, query:$q){ nodes{ id content{ ... on Issue { number } } } } } } }`,
                  { projectId, q: String(issue.number) }
                );
                const it = srch?.node?.items?.nodes?.find(n=>n.content?.number===issue.number);
                if (it) return it.id;

                const add = await github.graphql(
                  `mutation($projectId:ID!, $contentId:ID!){ addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item { id } } }`,
                  { projectId, contentId: issueId }
                );
                return add?.addProjectV2ItemById?.item?.id;
              } catch(e) {
                log(`Error en ensureItem: ${e.message}`);
                return null;
              }
            }

            async function getFields(projectId){
              const r = await github.graphql(
                `query($projectId:ID!){ node(id:$projectId){ ... on ProjectV2 { fields(first:50){ nodes{ ... on ProjectV2FieldCommon { id name dataType } ... on ProjectV2SingleSelectField { id name options { id name } } } } } } }`,
                { projectId }
              );
              return r?.node?.fields?.nodes || [];
            }

            const setSelect = async(projectId,itemId,field,optName)=>{
              if(!projectId || !itemId || !field || !optName) return;
              const opts = field.options || [];
              const opt = opts.find(o=>norm(o.name)===norm(optName)) || opts.find(o=>norm(o.name).includes(norm(optName)));
              if(!opt) return;
              await github.graphql(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){ updateProjectV2ItemFieldValue(input:{projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ singleSelectOptionId:$opt }}){ clientMutationId } }`,
                { projectId, itemId, fieldId: field.id, opt: opt.id }
              ).catch(()=>null);
            }

            const setText = async(projectId,itemId,fieldId,val)=>{
              if(!projectId || !itemId || !fieldId) return;  
              await github.graphql(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $val:String!){ updateProjectV2ItemFieldValue(input:{projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ text:$val }}){ clientMutationId } }`,
                { projectId, itemId, fieldId: fieldId, val: val || "" }
              ).catch(()=>null);
            }

            const setDate = async(projectId,itemId,fieldId,ymd)=>{
              if(!projectId || !itemId || !fieldId || !ymd) return;
              await github.graphql(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $val:Date!){ updateProjectV2ItemFieldValue(input:{projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{ date:$val }}){ clientMutationId } }`,
                { projectId, itemId, fieldId: fieldId, val: ymd }
              ).catch(()=>null);
            }

            // ============================================
            //                RUTA ISSUE USER
            // ============================================
            if (hasUserLabel) {
              let projectIdUser = await findProjectV2User();
              if (!projectIdUser) projectIdUser = await findProjectV2Main(); // Fallback

              if (!projectIdUser) { log('No Project found for User Issue'); return; }
              const itemIdUser = await ensureItem(projectIdUser);
              if (!itemIdUser) return;

              const fieldsUser = await getFields(projectIdUser);
              const byU = (names) => {
                const want = names.map(n => norm(n));
                return fieldsUser.find(f => {
                  const fn = norm(f?.name);
                  return want.some(w => fn === w || fn.includes(w));
                });
              }

              const fStatusU    = byU(['Status']);
              const fStatusCccU = byU(['Status_CCC','Status CCC','status_ccc']);
              const fReasonU    = byU(['Reason for change','Motivo de cambio']);
              const fRiskU      = byU(['Risk','Riesgo']);
              const fSolicU     = byU(['Solicitor']);
              const fDeptU      = byU(['Department','√Årea / Departamento']);
              const fEmailU     = byU(['Contact Email']);
              const fDateAppU   = byU(['Date of application']);
              const fDescU      = byU(['Description of the requested change','Descripci√≥n del cambio solicitado']);
              const fExplU      = byU(['Explanation of the reason','Motivo del cambio']);
              const fNotesU     = byU(['Additional comments','Observaciones adicionales']);

              const vDept   = grab('√Årea / Departamento') || grab('Department');
              const vReason = grab('Motivo de cambio'); 
              const vPrior  = grab('Prioridad') || grab('priorityname') || grab('Priority') || '';
              let   vDesc   = grab('Descripci√≥n del cambio solicitado *') || grab('Descripci√≥n del cambio solicitado') || grab('Description of the requested change');
              let   vExpl   = grab('Motivo del cambio *') || grab('Motivo del cambio') || grab('Explanation of the reason for the change');
              const vNotes  = grab('Observaciones adicionales') || grab('Additional comments');
              const vEmail  = grab('Email') || grab('Contact Email');

              if(!vDesc) vDesc = (grab('Descripci√≥n del cambio') || '').trim();
              if(!vExpl) vExpl = (grab('Explicaci√≥n del motivo') || '').trim();

              const authorLogin = issue.user?.login || context.actor;
              
              function translateReason(reason) {
                const r = norm(reason);
                if (r.includes('correcci√≥n') || r.includes('error')) return 'Error Correction';
                if (r.includes('mejora funcional')) return 'Functional Improvement';
                if (r.includes('est√©tico')) return 'Cosmetic Change';
                if (r.includes('otro')) return 'Other';
                return r;
              }
              const translatedReason = translateReason(vReason);

              function pickRiskFromPriority(priority, riskField){
                const opts = (riskField?.options || []).map(o => o.name);
                const names = opts.map(n => norm(n));
                const high  = opts[names.findIndex(n => /high|alto/.test(n))]   ?? opts.find(o=>/high|alto/i.test(o))   ?? 'High';
                const med   = opts[names.findIndex(n => /medium|medio/.test(n))]?? opts.find(o=>/medium|medio/i.test(o))?? 'Medium';
                const low   = opts[names.findIndex(n => /low|bajo/.test(n))]    ?? opts.find(o=>/low|bajo/i.test(o))    ?? 'Low';
                const v = norm(priority);
                if (/(crit|urg|alta|alto|high)/.test(v))   return high;
                if (/(baj|baja|low)/.test(v))              return low;
                return med;
              }

              // --- CAMBIO CLAVE: CERRAR COMO NOT PLANNED PERO MANTENER EN BACKLOG ---
              if (context.payload.action === 'opened') {
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: issue.number,
                  state: 'closed',
                  state_reason: 'not_planned', // Se cierra como not planned
                });
                // Pero en el Proyecto se pone como Backlog
                await setSelect(projectIdUser, itemIdUser, fStatusU, 'Backlog');
                await setSelect(projectIdUser, itemIdUser, fStatusCccU, 'Inbox');
              }

              await setText (projectIdUser, itemIdUser, fSolicU?.id,   authorLogin);
              await setText (projectIdUser, itemIdUser, fEmailU?.id,   vEmail || '');
              await setDate (projectIdUser, itemIdUser, fDateAppU?.id, new Date().toISOString().slice(0,10));
              await setSelect(projectIdUser, itemIdUser, fReasonU,     translatedReason);
              await setSelect(projectIdUser, itemIdUser, fRiskU,       pickRiskFromPriority(vPrior, fRiskU));
              await setText (projectIdUser, itemIdUser, fDeptU?.id,    vDept);
              await setText (projectIdUser, itemIdUser, fDescU?.id,    vDesc);
              await setText (projectIdUser, itemIdUser, fExplU?.id,    vExpl);
              await setText (projectIdUser, itemIdUser, fNotesU?.id,   vNotes);
              
              return;
            }
            
            // ============================================
            //           RUTA RFC MAIN (Sin Label User)
            // ============================================
            const projectIdMain = await findProjectV2Main();
            if (!projectIdMain) { log('Project Main not found'); return; }
            const itemIdMain = await ensureItem(projectIdMain);
            if (!itemIdMain) return;
            const fieldsMain = await getFields(projectIdMain);
            
            const byM = (names)=> {
              const want = names.map(n => norm(n));
              return fieldsMain.find(f => {
                const fn = norm(f?.name);
                return want.some(w => fn === w || fn.includes(w));
              });
            };

            const fStatusM    = byM(['Status','Estado']);
            const fStatusCccM = byM(['Status_CCC','Status CCC','status_ccc']);
            const fTipoM      = byM(['Change Type','Tipo de cambio']);
            const fRiesgoM    = byM(['Risk','Riesgo']);
            const fImpactoM   = byM(['Impact','Impacto']);
            const fPlanM      = byM(['Implementation Plan','Plan de implementaci√≥n']);
            const fRollbackM  = byM(['RollBack Planning','Rollback Plan','Plan de reversa (rollback)']);
            const fPruebasM   = byM(['Test Planning','Plan de pruebas']);
            const fAprobM     = byM(['Approvers','Aprobadores requeridos']);
            const fSolicM     = byM(['Solicitante','Solicitor','Applicant','Requester']);

            // --- CAMBIO CLAVE: CERRAR COMO NOT PLANNED Y ESTADO NOT PLANNED/INBOX ---
            if (context.payload.action === 'opened') {
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'not_planned',
              });
              await setSelect(projectIdMain, itemIdMain, fStatusM, 'Not Planned');
              await setSelect(projectIdMain, itemIdMain, fStatusCccM, 'Inbox');

              // Crear comentario de confirmaci√≥n
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issue.number,
                body: `## üìã Formulario Recibido y Procesado

                El formulario ha sido agregado exitosamente al proyecto para revisi√≥n.

                **Estado actual:** Cerrado como "Not Planned" (pendiente de aprobaci√≥n)

                **Pr√≥ximos pasos:**
                - El equipo CCC revisar√° la solicitud
                - Para aprobar: Un miembro del equipo CCC agregar√° la etiqueta \`approved\` (la issue se reabrir√° autom√°ticamente)
                - Para denegar: Se agregar√° la etiqueta \`denied\`

                **Fecha de procesamiento:** ${new Date().toISOString().slice(0, 19).replace('T', ' ')}`
              });
            }

            await setSelect(projectIdMain, itemIdMain, fTipoM,    tipo);
            await setSelect(projectIdMain, itemIdMain, fRiesgoM, riesgo);
            await setText  (projectIdMain, itemIdMain, fImpactoM?.id, grab('Impacto') || grab('Impact'));
            await setText  (projectIdMain, itemIdMain, fPlanM?.id,    grab('Plan de implementaci√≥n') || grab('Implementation Plan'));
            await setText  (projectIdMain, itemIdMain, fRollbackM?.id,grab('Plan de reversa \\(rollback\\)') || grab('RollBack Planning') || grab('Rollback Plan'));
            await setText  (projectIdMain, itemIdMain, fPruebasM?.id, grab('Plan de pruebas') || grab('Test Planning'));
            await setText  (projectIdMain, itemIdMain, fAprobM?.id,   grab('Aprobadores requeridos') || grab('Approvers'));
            await setText  (projectIdMain, itemIdMain, fSolicM?.id,   grab('Solicitante') || grab('Solicitor') || grab('Applicant') || grab('Requester'));

            log('‚úÖ Proceso RFC Finalizado Correctamente');

  # --- Job: process-user-approval (Solo para 'user') ---
  process-user-approval:
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'labeled' &&
      (github.event.label.name == 'approved' ||
        github.event.label.name == 'Approved' ||
        github.event.label.name == 'aprobado' ||
        github.event.label.name == 'Aprobado') &&
      contains(github.event.issue.labels.*.name, 'user')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        id: check_fields
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const issue = context.payload.issue;
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();

            const actor = context.actor;
            const ORG_LOGIN = process.env.ORG_LOGIN;

            let isCccMember = false;
            if (ORG_LOGIN) {
              try {
                await github.rest.teams.getMembershipForUserInOrg({
                  org: ORG_LOGIN,
                  team_slug: 'ccc',
                  username: actor
                });
                isCccMember = true;
              } catch (error) {
                if (error.status === 404) {
                  isCccMember = false;
                } else {
                  console.log(`Error al verificar membres√≠a: ${error.message}`);
                  isCccMember = false;
                }
              }
            }

            if (!isCccMember) {
              console.log(`Usuario ${actor} no pertenece al equipo "ccc". Acceso denegado.`);
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                name: context.payload.label.name
              }).catch(() => {});
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `## ‚õî Permiso Denegado

              @${actor}, no tienes permisos para aprobar cambios. Solo los miembros del equipo **ccc** pueden aprobar o denegar solicitudes.`
                            });
                            return;
                          }

                          const hasUser = (issue.labels || []).some(
                            (l) => norm(l.name) === 'user'
                          );
                          if (!hasUser) {
                            console.log('Issue no tiene label "user". Saltando.');
                            return;
                          }

                          const USER_LOGIN = process.env.USER_LOGIN;
                          const PN_USER    = parseInt(process.env.PROJECT_NUMBER_USER||'0',10);
                          const userProjUrl = `https://github.com/users/${USER_LOGIN}/projects/${PN_USER}`;

                          async function getUserProjByNum(n){
                            const r = await github.graphql(
                              `query($login:String!){
                                user(login:$login){
                                  projectsV2(first:50){
                                    nodes{ id number }
                                  }
                                }
                              }`,
                              { login: USER_LOGIN }
                            ).catch(()=>null);
                            return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
                          }

                          async function findItemId(projectId, issueNumber){
                            const r = await github.graphql(
                              `query($projectId:ID!, $q:String!){
                                node(id:$projectId){
                                  ... on ProjectV2 {
                                    items(first:50, query:$q){
                                      nodes{
                                        id
                                        content{ ... on Issue { number } }
                                      }
                                    }
                                  }
                                }
                              }`,
                              { projectId, q: String(issueNumber) }
                            );
                            return r.node.items.nodes.find(n=>n.content?.number===issueNumber)?.id || null;
                          }

                          async function getFields(projectId){
                            const r = await github.graphql(
                              `query($projectId:ID!){
                                node(id:$projectId){
                                  ... on ProjectV2 {
                                    fields(first:100){
                                      nodes{
                                        ... on ProjectV2FieldCommon { id name dataType }
                                        ... on ProjectV2SingleSelectField { id name options { id name } }
                                      }
                                    }
                                  }
                                }
                              }`,
                              { projectId }
                            );
                            return r.node.fields.nodes;
                          }

                          async function getFieldValues(itemId){
                            const r = await github.graphql(
                              `query($itemId:ID!){
                                node(id:$itemId){
                                  ... on ProjectV2Item {
                                    fieldValues(first:100){
                                      nodes{
                                        ... on ProjectV2ItemFieldTextValue {
                                          text
                                          field { ... on ProjectV2FieldCommon { id name } }
                                        }
                                        ... on ProjectV2ItemFieldDateValue {
                                          date
                                          field { ... on ProjectV2FieldCommon { id name } }
                                        }
                                        ... on ProjectV2ItemFieldSingleSelectValue {
                                          name
                                          optionId
                                          field { ... on ProjectV2FieldCommon { id name } }
                                        }
                                      }
                                    }
                                  }
                                }
                              }`,
                              { itemId }
                            );
                            return r.node.fieldValues.nodes;
                          }

                          const by = (fields, names) =>
                            names.map(n => fields.find(f => norm(f?.name) === norm(n))).find(Boolean);

                          const projectId = await getUserProjByNum(PN_USER);
                          if(!projectId) {
                            console.log('Proyecto de usuario no encontrado.');
                            return;
                          }
                          const itemId = await findItemId(projectId, issue.number);
                          if(!itemId) {
                            console.log('Item no encontrado en el proyecto.');
                            return;
                          }

                          const fields = await getFields(projectId);
                          const fStatusCcc = by(fields, ['Status_CCC','Status CCC','status_ccc']);
                          const fChangeType= by(fields, ['Change Type', 'Tipo de cambio']);
                          const fImpact    = by(fields, ['Impact']);
                          const fPlan      = by(fields, ['Implementation Plan']);
                          const fRollback  = by(fields, ['RollBack Planning','Rollback Plan']);
                          const fPruebas   = by(fields, ['Test Planning']);
                          const fAprob     = by(fields, ['Approvers']);
                          const fStart     = by(fields, ['Start date']);
                          const fTarget    = by(fields, ['Target date']);

                          const values = await getFieldValues(itemId);
                          function getValue(field){
                            if(!field) return null;
                            const v = values.find(n => norm(n.field?.name) === norm(field.name));
                            if(!v) return null;
                            if ('text' in v) return (v.text||'').trim();
                            if ('date' in v) return (v.date||'').trim();
                            if ('name' in v) return (v.name||'').trim();
                            return null;
                          }

                          const missing = [];
                          if(!getValue(fChangeType)) missing.push('Change Type (estandar/normal/emergencia)');
                          if(!getValue(fImpact))   missing.push('Impact');
                          if(!getValue(fPlan))     missing.push('Implementation Plan');
                          if(!getValue(fRollback)) missing.push('RollBack Planning');
                          if(!getValue(fPruebas))  missing.push('Test Planning');
                          if(!getValue(fAprob))    missing.push('Approvers');
                          if(!getValue(fStart))    missing.push('Start date (YYYY-MM-DD)');
                          if(!getValue(fTarget))   missing.push('Target date (YYYY-MM-DD)');

                          core.setOutput('has_missing_fields', missing.length > 0 ? 'true' : 'false');
                          core.setOutput('missing_fields', JSON.stringify(missing));
                          core.setOutput('project_id', projectId);
                          core.setOutput('item_id', itemId);
                          core.setOutput('project_url', userProjUrl);

      - name: Add CCC Form if Missing Fields
        if: steps.check_fields.outputs.has_missing_fields == 'true'
        uses: actions/github-script@v7
        env:
          MISSING_FIELDS: ${{ steps.check_fields.outputs.missing_fields }}
          PROJECT_URL_OUT: ${{ steps.check_fields.outputs.project_url }}
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const issue = context.payload.issue;

            let missing = [];
            try {
              missing = JSON.parse(process.env.MISSING_FIELDS || '[]');
            } catch (e) {
              console.log('Error al parsear MISSING_FIELDS:', e.message);
              missing = [];
            }

            const projectUrl = process.env.PROJECT_URL_OUT || '';

            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number
            });
            
            const hasForm = comments.data.some(c => (c.body || '').includes('Formulario de Control de Cambios (CCC)'));
            
            if (hasForm) {
              console.log('El formulario CCC ya existe');
              return;
            }
            
            const list = missing.map(m => `- [ ] \`${m}\``).join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `## üìã Formulario de Control de Cambios (CCC)

            > ‚ö†Ô∏è **Aprobaci√≥n pendiente - Informaci√≥n requerida**
            > 
            > Para completar la aprobaci√≥n, necesitas llenar los siguientes campos **directamente en el proyecto**.

            ---

            ### ‚ùå Campos faltantes en el proyecto:

            ${list}

            ---

            ### üìù C√≥mo completar la informaci√≥n

            **Opci√≥n 1: Llenar en el proyecto (Recomendado)**

            1. **[Haz clic aqu√≠ para ir al Proyecto ‚Üí](${projectUrl})**
            2. Busca esta tarjeta (Issue #${issue.number})
            3. Llena los campos indicados arriba haciendo clic en cada celda
            4. Vuelve a este issue y **comenta** \`/verificar\` para validar

            **Opci√≥n 2: Responder en este issue**

            Tambi√©n puedes completar la informaci√≥n directamente aqu√≠. Copia y llena la siguiente plantilla:

            <details>
            <summary><b>üìã Plantilla de informaci√≥n CCC</b> (Click para expandir)</summary>

            \`\`\`
            ### Change Type
            Tipo de cambio: [ ] estandar [ ] normal [ ] emergencia

            ### Impact
            Describe el impacto del cambio:
            - Usuarios afectados: 
            - Sistemas impactados: 
            - Nivel de criticidad: [ ] Bajo [ ] Medio [ ] Alto

            ### Implementation Plan
            Pasos detallados de implementaci√≥n:
            1. 
            2. 
            3. 

            Recursos necesarios:
            - Personal: @
            - Tiempo estimado: ___ horas
            - Ventana de mantenimiento: [ ] S√≠ [ ] No

            ### RollBack Planning
            Procedimiento de rollback:
            1. 
            2. 
            3. 

            Tiempo estimado de rollback: ___ minutos
            ¬øEs completamente reversible? [ ] S√≠ [ ] No

            ### Test Planning
            Estrategia de testing:
            - Tests unitarios: [ ] Completos
            - Tests de integraci√≥n: [ ] Completos
            - Tests E2E: [ ] Completos

            Casos de prueba cr√≠ticos:
            1. 
            2. 

            ### Approvers
            Aprobadores requeridos:
            - [ ] Tech Lead: @
            - [ ] Product Owner: @
            - [ ] DevOps: @
            - [ ] Otro: @

            ### Start date
            Fecha de inicio (YYYY-MM-DD): 

            ### Target date
            Fecha objetivo (YYYY-MM-DD): 
            \`\`\`

            **Una vez completado**, comenta: \`/actualizar\` para sincronizar con el proyecto

            </details>

            ---

            ### ‚úÖ Comandos disponibles

            - \`/verificar\` - Verificar si ya se completaron los campos en el proyecto
            - \`/actualizar\` - Actualizar el proyecto con la informaci√≥n de este issue
            - \`/ayuda\` - Mostrar ayuda sobre c√≥mo llenar cada campo

            ---

            _ü§ñ Este formulario fue generado autom√°ticamente. La etiqueta "approved" se removi√≥ temporalmente hasta completar la informaci√≥n._`
                        });

      - name: Revert Status and Remove Label
        if: steps.check_fields.outputs.has_missing_fields == 'true'
        uses: actions/github-script@v7
        env:
          PROJECT_ID_OUT: ${{ steps.check_fields.outputs.project_id }}
          ITEM_ID_OUT: ${{ steps.check_fields.outputs.item_id }}
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const projectId = process.env.PROJECT_ID_OUT;
            const itemId = process.env.ITEM_ID_OUT;
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();
            
            if (!projectId || !itemId) {
              console.log('PROJECT_ID_OUT o ITEM_ID_OUT no definidos. Saltando.');
              return;
            }

            const fields = await github.graphql(
              `query($projectId:ID!){
                node(id:$projectId){
                  ... on ProjectV2 {
                    fields(first:50){
                      nodes{
                        ... on ProjectV2FieldCommon { id name }
                        ... on ProjectV2SingleSelectField { id name options{ id name } }
                      }
                    }
                  }
                }
              }`,
              { projectId }
            );
            
            const fStatusCcc = fields.node.fields.nodes.find(f => {
              const fn = norm(f?.name);
              return fn === 'status_ccc' || fn === 'status ccc' || fn.includes('status_ccc');
            });
            
            if (fStatusCcc) {
              const opts = fStatusCcc.options || [];
              const inbox = opts.find(o => norm(o.name) === 'inbox') || opts.find(o => norm(o.name).includes('inbox'));
              
              if (inbox) {
                await github.graphql(
                  `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                    updateProjectV2ItemFieldValue(input:{
                      projectId:$projectId,
                      itemId:$itemId,
                      fieldId:$fieldId,
                      value:{ singleSelectOptionId:$opt }
                    }){
                      clientMutationId
                    }
                  }`,
                  { projectId, itemId, fieldId: fStatusCcc.id, opt: inbox.id }
                );
              }
            }
            
            try {
              const labelName = context.payload.label.name;
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                name: labelName
              });
            } catch(e) {
              console.log('No se pudo remover el label:', e.message);
            }

      - name: Approve if Complete
        if: steps.check_fields.outputs.has_missing_fields == 'false'
        uses: actions/github-script@v7
        env:
          PROJECT_ID_OUT: ${{ steps.check_fields.outputs.project_id }}
          ITEM_ID_OUT: ${{ steps.check_fields.outputs.item_id }}
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const projectId = process.env.PROJECT_ID_OUT;
            const itemId = process.env.ITEM_ID_OUT;
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();

            if (!projectId || !itemId) {
              console.log('PROJECT_ID_OUT o ITEM_ID_OUT no definidos. Saltando.');
              return;
            }

            async function setSelect(field,optName){
              if(!field || !optName) return false;
              const opts = field.options || [];
              const normalizedOptName = norm(optName);
              const wanted = opts.find(o=>norm(o.name)===normalizedOptName) || opts.find(o=>norm(o.name).includes(normalizedOptName));
              if(!wanted) {
                console.log(`Opci√≥n "${normalizedOptName}" no encontrada para el campo "${field.name}"`);
                return false;
              }
              await github.graphql(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ singleSelectOptionId:$opt }
                  }){
                    clientMutationId
                  }
                }`,
                { projectId, itemId, fieldId: field.id, opt: wanted.id }
              );
              return true;
            }

            const fields = await github.graphql(
              `query($projectId:ID!){
                node(id:$projectId){
                  ... on ProjectV2 {
                    fields(first:50){
                      nodes{
                        ... on ProjectV2FieldCommon { id name }
                        ... on ProjectV2SingleSelectField { id name options{ id name } }
                      }
                    }
                  }
                }
              }`,
              { projectId }
            );
            
            const allFields = fields.node.fields.nodes;
            
            const fStatusCcc = allFields.find(f => {
              const fn = norm(f?.name);
              return fn === 'status_ccc' || fn === 'status ccc' || fn.includes('status_ccc');
            });
            
            const fStatus = allFields.find(f => norm(f?.name) === 'status');
            
            await setSelect(fStatusCcc, 'Approved');
            await setSelect(fStatus, 'Ready');
            
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                name: 'denied'
              });
            } catch(e) {}
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: `## ‚úÖ Aprobaci√≥n Completada

            Todos los campos requeridos est√°n completos. El cambio ha sido aprobado exitosamente.

            **Estado actualizado:** Ready  
            **Estado CCC:** Approved  
            **Fecha:** ${new Date().toISOString().slice(0, 19).replace('T', ' ')}`
                        });

  # --- Job: process-rfc-approval (Solo para 'rfc' sin 'user') ---
  process-rfc-approval:
    if: |
      github.event_name == 'issues' &&
      github.event.action == 'labeled' &&
      (github.event.label.name == 'approved' ||
        github.event.label.name == 'Approved' ||
        github.event.label.name == 'aprobado' ||
        github.event.label.name == 'Aprobado') &&
      contains(github.event.issue.labels.*.name, 'rfc') &&
      !contains(github.event.issue.labels.*.name, 'user')
    runs-on: ubuntu-latest
    steps:
      - name: Set Status to Ready and Approved
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const issue = context.payload.issue;
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();

            const actor = context.actor;
            const ORG_LOGIN  = process.env.ORG_LOGIN;

            let isCccMember = false;
            if (ORG_LOGIN) {
              try {
                await github.rest.teams.getMembershipForUserInOrg({
                  org: ORG_LOGIN,
                  team_slug: 'ccc',
                  username: actor
                });
                isCccMember = true;
              } catch (error) {
                if (error.status === 404) {
                  isCccMember = false;
                } else {
                  console.log(`Error al verificar membres√≠a: ${error.message}`);
                  isCccMember = false;
                }
              }
            }

            if (!isCccMember) {
              console.log(`Usuario ${actor} no pertenece al equipo "ccc". Acceso denegado.`);
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                name: context.payload.label.name
              }).catch(() => {});
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `## ‚õî Permiso Denegado

                @${actor}, no tienes permisos para aprobar cambios. Solo los miembros del equipo **ccc** pueden aprobar o denegar solicitudes.`
                              });
                              return;
                            }

                            const USER_LOGIN = process.env.USER_LOGIN;
                            const PN_MAIN    = parseInt(process.env.PROJECT_NUMBER,10);
                            
                            async function getUserProjByNum(n){
                              const r = await github.graphql(
                                `query($login:String!){
                                  user(login:$login){
                                    projectsV2(first:50){
                                      nodes{ id number }
                                    }
                                  }
                                }`,
                                { login: USER_LOGIN }
                              ).catch(()=>null);
                              return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
                            }

                            async function getOrgProjByNum(n){
                              if(!ORG_LOGIN) return null;
                              const r = await github.graphql(
                                `query($login:String!){
                                  organization(login:$login){
                                    projectsV2(first:50){
                                      nodes{ id number }
                                    }
                                  }
                                }`,
                                { login: ORG_LOGIN }
                              ).catch(()=>null);
                              return r?.organization?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
                            }
                            
                            async function findItemId(projectId, issueNumber){
                              const r = await github.graphql(
                                `query($projectId:ID!, $q:String!){
                                  node(id:$projectId){
                                    ... on ProjectV2 {
                                      items(first:50, query:$q){
                                        nodes{
                                          id
                                          content{ ... on Issue { number } }
                                        }
                                      }
                                    }
                                  }
                                }`,
                                { projectId, q: String(issueNumber) }
                              );
                              return r?.node?.items?.nodes?.find(n=>n.content?.number===issueNumber)?.id || null;
                            }

                            async function setSelect(projectId, itemId, field, optName){
                              if(!field || !optName) return false;
                              const opts = field.options || [];
                              const normalizedOptName = norm(optName);
                              const wanted = opts.find(o=>norm(o.name)===normalizedOptName) || opts.find(o=>norm(o.name).includes(normalizedOptName));
                              if(!wanted) {
                                console.log(`Opci√≥n "${normalizedOptName}" no encontrada para el campo "${field.name}"`);
                                return false;
                              }
                              await github.graphql(
                                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                                  updateProjectV2ItemFieldValue(input:{
                                    projectId:$projectId,
                                    itemId:$itemId,
                                    fieldId:$fieldId,
                                    value:{ singleSelectOptionId:$opt }
                                  }){
                                    clientMutationId
                                  }
                                }`,
                                { projectId, itemId, fieldId: field.id, opt: wanted.id }
                              );
                              return true;
                            }
                            
                            const projectId = await getUserProjByNum(PN_MAIN) || await getOrgProjByNum(PN_MAIN);
                            if (!projectId) {
                              console.log('Proyecto principal no encontrado.');
                              return;
                            }
                            
                            const itemId = await findItemId(projectId, issue.number);
                            if (!itemId) {
                              console.log('Item no encontrado en el proyecto principal.');
                              return;
                            }
                            
                            if (issue.state === 'closed') {
                              console.log('El issue estaba cerrado. Reabriendo.');
                              await github.rest.issues.update({
                                owner: context.repo.owner,
                                repo: context.repo.repo,
                                issue_number: issue.number,
                                state: 'open'
                              });
                            }

                            const fields = await github.graphql(
                              `query($projectId:ID!){
                                node(id:$projectId){
                                  ... on ProjectV2 {
                                    fields(first:50){
                                      nodes{
                                        ... on ProjectV2FieldCommon { id name }
                                        ... on ProjectV2SingleSelectField { id name options{ id name } }
                                      }
                                    }
                                  }
                                }
                              }`,
                              { projectId }
                            );
                            
                            const allFields = fields.node.fields.nodes;
                            const fStatusCcc = allFields.find(f => norm(f?.name) === 'status_ccc');
                            const fStatus = allFields.find(f => norm(f?.name) === 'status');
                            
                            await setSelect(projectId, itemId, fStatusCcc, 'Approved');
                            await setSelect(projectId, itemId, fStatus, 'Ready');
                            
                            try {
                              await github.rest.issues.removeLabel({
                                owner: context.repo.owner,
                                repo: context.repo.repo,
                                issue_number: context.payload.issue.number,
                                name: 'denied'
                              });
                            } catch(e) {}
                            
                            await github.rest.issues.createComment({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: issue.number,
                              body: `## ‚úÖ RFC Aprobado

                El RFC ha sido aprobado.

                **Estado actualizado:** Ready  
                **Estado CCC:** Approved  
                **Fecha:** ${new Date().toISOString().slice(0, 19).replace('T', ' ')}`
                            });

                  # --- Job: process-denial (para 'rfc' y 'user') ---
                  process-denial:
                    if: |
                      github.event_name == 'issues' &&
                      github.event.action == 'labeled' &&
                      (github.event.label.name == 'denied' ||
                      github.event.label.name == 'Denegado' ||
                      github.event.label.name == 'denegado')
                    runs-on: ubuntu-latest
                    steps:
                      - name: Set Status to Not Planned and Denied
                        uses: actions/github-script@v7
                        with:
                          github-token: ${{ secrets.PROJECTS_PAT }}
                          script: |
                            const issue = context.payload.issue;
                            const norm = (s) =>
                              (s ?? '')
                                .toString()
                                .normalize('NFD')
                                .replace(/\p{Diacritic}/gu, '')
                                .trim()
                                .toLowerCase();

                            const actor = context.actor;
                            const ORG_LOGIN  = process.env.ORG_LOGIN;

                            let isCccMember = false;
                            if (ORG_LOGIN) {
                              try {
                                await github.rest.teams.getMembershipForUserInOrg({
                                  org: ORG_LOGIN,
                                  team_slug: 'ccc',
                                  username: actor
                                });
                                isCccMember = true;
                              } catch (error) {
                                if (error.status === 404) {
                                  isCccMember = false;
                                } else {
                                  console.log(`Error al verificar membres√≠a: ${error.message}`);
                                  isCccMember = false;
                                }
                              }
                            }

                            if (!isCccMember) {
                              console.log(`Usuario ${actor} no pertenece al equipo "ccc". Acceso denegado.`);
                              await github.rest.issues.removeLabel({
                                owner: context.repo.owner,
                                repo: context.repo.repo,
                                issue_number: issue.number,
                                name: context.payload.label.name
                              }).catch(() => {});
                              await github.rest.issues.createComment({
                                owner: context.repo.owner,
                                repo: context.repo.repo,
                                issue_number: issue.number,
                                body: `## ‚õî Permiso Denegado

                @${actor}, no tienes permisos para denegar cambios. Solo los miembros del equipo **ccc** pueden aprobar o denegar solicitudes.`
                              });
                              return;
                            }

                            const hasRfc = (issue.labels || []).some(l => norm(l.name) === 'rfc');
                            if (!hasRfc) {
                              console.log('No es un issue RFC, saltando.');
                              return;
                            }

                            const hasUser = (issue.labels || []).some(l => norm(l.name) === 'user');

                            const USER_LOGIN = process.env.USER_LOGIN;
                            const ORG_LOGIN2 = process.env.ORG_LOGIN;
                            const PN_MAIN    = parseInt(process.env.PROJECT_NUMBER,10);
                            const PN_USER = parseInt(process.env.PROJECT_NUMBER_USER || '0', 10);
                            
                            async function getUserProjByNum(n){
                              const r = await github.graphql(
                                `query($login:String!){
                                  user(login:$login){
                                    projectsV2(first:50){
                                      nodes{ id number }
                                    }
                                  }
                                }`,
                                { login: USER_LOGIN }
                              ).catch(()=>null);
                              return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
                            }
                            
                            async function getOrgProjByNum(n){
                              if(!ORG_LOGIN2) return null;
                              const r = await github.graphql(
                                `query($login:String!){
                                  organization(login:$login){
                                    projectsV2(first:50){
                                      nodes{ id number }
                                    }
                                  }
                                }`,
                                { login: ORG_LOGIN2 }
                              ).catch(()=>null);
                              return r?.organization?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
                            }

                            async function findItemId(projectId, issueNumber){
                              const r = await github.graphql(
                                `query($projectId:ID!, $q:String!){
                                  node(id:$projectId){
                                    ... on ProjectV2 {
                                      items(first:50, query:$q){
                                        nodes{
                                          id
                                          content{ ... on Issue { number } }
                                        }
                                      }
                                    }
                                  }
                                }`,
                                { projectId, q: String(issueNumber) }
                              );
                              return r?.node?.items?.nodes?.find(n=>n.content?.number===issueNumber)?.id || null;
                            }
            
            let projectId = null;
            if (hasUser) {
              projectId = await getUserProjByNum(PN_USER);
            } else {
              projectId = await getUserProjByNum(PN_MAIN) || await getOrgProjByNum(PN_MAIN);
            }

            if (!projectId) {
              console.log('Proyecto (user o main) no encontrado.');
              return;
            }
            
            const itemId = await findItemId(projectId, issue.number);
            if (!itemId) {
              console.log('Item no encontrado en el proyecto.');
              return;
            }

            if (issue.state === 'open') {
              console.log('El issue est√° abierto. Cerrando como "not_planned".');
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'not_planned'
              });
            }

            async function setSelect(field,optName){
              if(!field || !optName) return false;
              const opts = field.options || [];
              const normalizedOptName = norm(optName);
              const wanted = opts.find(o=>norm(o.name)===normalizedOptName) || opts.find(o=>norm(o.name).includes(normalizedOptName));
              if(!wanted) {
                console.log(`Opci√≥n "${normalizedOptName}" no encontrada para el campo "${field.name}"`);
                return false;
              }
              await github.graphql(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ singleSelectOptionId:$opt }
                  }){
                    clientMutationId
                  }
                }`,
                { projectId, itemId, fieldId: field.id, opt: wanted.id }
              );
              return true;
            }

            const fields = await github.graphql(
              `query($projectId:ID!){
                node(id:$projectId){
                  ... on ProjectV2 {
                    fields(first:50){
                      nodes{
                        ... on ProjectV2FieldCommon { id name }
                        ... on ProjectV2SingleSelectField { id name options{ id name } }
                      }
                    }
                  }
                }
              }`,
              { projectId }
            );
            
            const allFields = fields.node.fields.nodes;
            
            const fStatusCcc = allFields.find(f => {
              const fn = norm(f?.name);
              return fn === 'status_ccc' || fn === 'status ccc' || fn.includes('status_ccc');
            });
            
            const fStatus = allFields.find(f => norm(f?.name) === 'status');
            
            await setSelect(fStatusCcc, 'Denied');
            await setSelect(fStatus, 'Not Planned');
            
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                name: 'approved'
              });
            } catch(e) {}
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `## ‚ùå Solicitud Denegada

            El issue ha sido marcado como denegado y cerrado.

            **Estado actualizado:** Not Planned  
            **Estado CCC:** Denied`
                        });

  # --- Job: process-pr-link (bloquea PRs a main sin RFC correcto) ---
  process-pr-link:
    if: github.event_name == 'pull_request' && (github.event.action == 'opened' || github.event.action == 'edited' || github.event.action == 'synchronize') && github.base_ref == 'main'
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR for RFC Process
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const pr = context.payload.pull_request;
            const prBody = pr.body || '';
            const prTitle = pr.title || '';
            const prNumber = pr.number;
            const content = prBody + ' ' + prTitle;
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();
            
            const allIssuesRegex = /#(\d+)/gi;
            const closingRegex = /(?:closes|fixes|resolves) #(\d+)/gi;
            
            let match;
            const allIssueNumbers = new Set();
            const closingNumbers = new Set();
            
            while ((match = allIssuesRegex.exec(content)) !== null) {
              allIssueNumbers.add(match[1]);
            }
            while ((match = closingRegex.exec(content)) !== null) {
              closingNumbers.add(match[1]);
            }
            
            if (allIssueNumbers.size === 0) {
              console.log('PR no linkea a ningun issue. Pasando.');
              return;
            }
            
            const USER_LOGIN = process.env.USER_LOGIN;
            const ORG_LOGIN  = process.env.ORG_LOGIN;
            const PN_MAIN    = parseInt(process.env.PROJECT_NUMBER,10);
            const PN_USER    = parseInt(process.env.PROJECT_NUMBER_USER||'0',10);
            
            async function getUserProjByNum(n){
              const r = await github.graphql(
                `query($login:String!){
                  user(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: USER_LOGIN }
              ).catch(()=>null);
              return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }

            async function getOrgProjByNum(n){
              if(!ORG_LOGIN) return null;
              const r = await github.graphql(
                `query($login:String!){
                  organization(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: ORG_LOGIN }
              ).catch(()=>null);
              return r?.organization?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }
            
            async function findItemId(projectId, issueNumber){
              const r = await github.graphql(
                `query($projectId:ID!, $q:String!){
                  node(id:$projectId){
                    ... on ProjectV2 {
                      items(first:50, query:$q){
                        nodes{
                          id
                          content{ ... on Issue { number } }
                        }
                      }
                    }
                  }
                }`,
                { projectId, q: String(issueNumber) }
              );
              return r?.node?.items?.nodes?.find(n=>n.content?.number===parseInt(issueNumber,10))?.id || null;
            }

            async function getFields(projectId){
              const r = await github.graphql(
                `query($projectId:ID!){
                  node(id:$projectId){
                    ... on ProjectV2 {
                      fields(first:100){
                        nodes{
                          ... on ProjectV2FieldCommon { id name dataType }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                        }
                      }
                    }
                  }
                }`,
                { projectId }
              );
              return r?.node?.fields?.nodes || [];
            }

            async function setSelect(projectId, itemId, field, optName){
              if(!field || !optName) return false;
              const opts = field.options || [];
              const normalizedOptName = norm(optName);
              const wanted = opts.find(o=>norm(o.name)===normalizedOptName) || opts.find(o=>norm(o.name).includes(normalizedOptName));
              if(!wanted) {
                console.log(`Opci√≥n "${normalizedOptName}" no encontrada para el campo "${field.name}"`);
                return false;
              }
              await github.graphql(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ singleSelectOptionId:$opt }
                  }){
                    clientMutationId
                  }
                }`,
                { projectId, itemId, fieldId: field.id, opt: wanted.id }
              );
              return true;
            }
            
            const prComments = new Map();
            let didFail = false;
            let hasOpenRfc = false;

            for (const issueNum of allIssueNumbers) {
              console.log(`Procesando issue #${issueNum}`);
              
              let issue;
              try {
                issue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum
                });
              } catch (e) {
                console.log(`No se pudo obtener issue #${issueNum}: ${e.message}`);
                continue;
              }
              
              const hasRfc = (issue.data.labels || []).some(l => norm(l.name) === 'rfc');
              if (!hasRfc) {
                console.log(`Issue #${issueNum} no es 'rfc'. Saltando.`);
                continue;
              }
              
              if (issue.data.state !== 'open') {
                console.log(`Issue #${issueNum} ya est√° cerrado. Verificando motivo...`);
                
                const hasDeniedLabel = (issue.data.labels || []).some(l => norm(l.name) === 'denied');
                const reason = issue.data.state_reason;
                let commentBody = '';

                if (hasDeniedLabel) {
                  commentBody = `‚ö†Ô∏è **Referencia a Issue Denegado:** El Issue #${issueNum} (referenciado en este PR) fue denegado y est√° cerrado.`;
                } else if (reason === 'not_planned') {
                  commentBody = `‚ÑπÔ∏è **Referencia a Issue No Planeado:** El Issue #${issueNum} (referenciado en este PR) est√° cerrado como "No Planeado".`;
                } else if (reason === 'completed') {
                  commentBody = `‚úÖ **Referencia a Issue Completado:** El Issue #${issueNum} (referenciado en este PR) ya fue completado.`;
                }
                
                if (commentBody && !prComments.has(commentBody)) {
                  prComments.set(commentBody, true);
                }
                
                continue;
              }
              
              hasOpenRfc = true; 
              
              if (!closingNumbers.has(issueNum)) {
                const commentBody = `‚ùå **ACCI√ìN REQUERIDA:** El Issue RFC #${issueNum} est√° abierto y debe cerrarse con este PR.

            Por favor, edita la descripci√≥n de este PR y a√±ade una palabra clave como \`closes #${issueNum}\`, \`fixes #${issueNum}\`, o \`resolves #${issueNum}\` para continuar.`;
                            if (!prComments.has(commentBody)) {
                              prComments.set(commentBody, true);
                              core.setFailed(`El Issue RFC #${issueNum} debe tener una palabra clave de cierre.`);
                              didFail = true;
                            }
                            continue;
                          }
                          
                          const hasUser = (issue.data.labels || []).some(l => norm(l.name) === 'user');
                          
                          let projectId = null;
                          if (hasUser) {
                            projectId = await getUserProjByNum(PN_USER);
                          } else {
                            projectId = await getUserProjByNum(PN_MAIN) || await getOrgProjByNum(PN_MAIN);
                          }
                          
                          if(!projectId) {
                            console.log(`No se pudo encontrar proyecto para issue #${issueNum}.`);
                            continue;
                          }

                          const itemId = await findItemId(projectId, issueNum);
                          if (!itemId) {
                            console.log(`Issue #${issueNum} no es un item en el proyecto.`);
                            continue;
                          }

                          const allFields = await getFields(projectId);
                          const fStatus = allFields.find(f => norm(f?.name) === 'status');
                          
                          if (!fStatus) {
                            console.log(`Campo "Status" no encontrado en el proyecto para #${issueNum}.`);
                            continue;
                          }
                          
                          const success = await setSelect(projectId, itemId, fStatus, 'In Review');
                          
                          if (success) {
                            await github.rest.issues.createComment({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: issueNum,
                              body: `## üîÑ En Revisi√≥n

            El estado ha sido actualizado a \`In Review\` debido al Pull Request #${prNumber}.`
                            });
                          }
                        }
                                                
                        if (prComments.size > 0) {
                          const finalComment = Array.from(prComments.keys()).join('\n\n---\n');
                          await github.rest.issues.createComment({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: prNumber,
                            body: finalComment
                          });
                        }

                        if (didFail) {
                          core.setFailed('Este PR no cumple con las reglas de vinculaci√≥n de issues RFC. Revisa los comentarios del bot.');
                          return;
                        }
                        
                        if (hasOpenRfc) {
                          console.log('Todos los RFCs abiertos fueron procesados. Job exitoso.');
                        } else {
                          console.log('PR no linkea a ning√∫n RFC abierto. Pasando.');
                        }

              # --- Job: process-pr-closed (PR Rechazado) ---
              process-pr-closed:
                if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.base_ref == 'main' && github.event.pull_request.merged == false
                runs-on: ubuntu-latest
                steps:
                  - name: Set Issue Status to In Progress
                    uses: actions/github-script@v7
                    with:
                      github-token: ${{ secrets.PROJECTS_PAT }}
                      script: |
                        const pr = context.payload.pull_request;
                        const prBody = pr.body || '';
                        const prTitle = pr.title || '';
                        const prNumber = pr.number;
                        const content = prBody + ' ' + prTitle;
                        const norm = (s) =>
                          (s ?? '')
                            .toString()
                            .normalize('NFD')
                            .replace(/\p{Diacritic}/gu, '')
                            .trim()
                            .toLowerCase();
                        
                        const issueRegex = /(?:closes|fixes|resolves) #(\d+)|#(\d+)/gi;
                        let match;
                        const issueNumbers = new Set();
                        
                        while ((match = issueRegex.exec(content)) !== null) {
                          issueNumbers.add(match[1] || match[2]);
                        }
                        
                        if (issueNumbers.size === 0) {
                          console.log('PR no linkea a ningun issue.');
                          return;
                        }
                        
                        const USER_LOGIN = process.env.USER_LOGIN;
                        const ORG_LOGIN  = process.env.ORG_LOGIN;
                        const PN_MAIN    = parseInt(process.env.PROJECT_NUMBER,10);
                        const PN_USER    = parseInt(process.env.PROJECT_NUMBER_USER||'0',10);
                        
                        async function getUserProjByNum(n){
                          const r = await github.graphql(
                            `query($login:String!){
                              user(login:$login){
                                projectsV2(first:50){
                                  nodes{ id number }
                                }
                              }
                            }`,
                            { login: USER_LOGIN }
                          ).catch(()=>null);
                          return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
                        }

                        async function getOrgProjByNum(n){
                          if(!ORG_LOGIN) return null;
                          const r = await github.graphql(
                            `query($login:String!){
                              organization(login:$login){
                                projectsV2(first:50){
                                  nodes{ id number }
                                }
                              }
                            }`,
                            { login: ORG_LOGIN }
                          ).catch(()=>null);
                          return r?.organization?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
                        }
                        
                        async function findItemId(projectId, issueNumber){
                          const r = await github.graphql(
                            `query($projectId:ID!, $q:String!){
                              node(id:$projectId){
                                ... on ProjectV2 {
                                  items(first:50, query:$q){
                                    nodes{
                                      id
                                      content{ ... on Issue { number } }
                                    }
                                  }
                                }
                              }
                            }`,
                            { projectId, q: String(issueNumber) }
              );
              return r?.node?.items?.nodes?.find(n=>n.content?.number===parseInt(issueNumber,10))?.id || null;
            }
            
            async function getFields(projectId){
              const r = await github.graphql(
                `query($projectId:ID!){
                  node(id:$projectId){
                    ... on ProjectV2 {
                      fields(first:50){
                        nodes{
                          ... on ProjectV2FieldCommon { id name }
                          ... on ProjectV2SingleSelectField { id name options{ id name } }
                        }
                      }
                    }
                  }
                }`,
                { projectId }
              );
              return r?.node?.fields?.nodes || [];
            }

            async function setSelect(projectId, itemId, field, optName){
              if(!field || !optName) return false;
              const opts = field.options || [];
              const normalizedOptName = norm(optName);
              const wanted = opts.find(o=>norm(o.name)===normalizedOptName) || opts.find(o=>norm(o.name).includes(normalizedOptName));
              if(!wanted) {
                console.log(`Opci√≥n "${normalizedOptName}" no encontrada para el campo "${field.name}"`);
                return false;
              }
              await github.graphql(
                `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ singleSelectOptionId:$opt }
                  }){
                    clientMutationId
                  }
                }`,
                { projectId, itemId, fieldId: field.id, opt: wanted.id }
              );
              return true;
            }

            for (const issueNum of issueNumbers) {
              console.log(`Procesando issue #${issueNum}`);
              
              let issue;
              try {
                issue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum
                });
              } catch (e) {
                console.log(`No se pudo obtener issue #${issueNum}: ${e.message}`);
                continue;
              }

              if (issue.data.state !== 'open') {
                console.log(`Issue #${issueNum} ya est√° cerrado. Saltando.`);
                continue;
              }
              
              const hasRfc = (issue.data.labels || []).some(l => norm(l.name) === 'rfc');
              if (!hasRfc) {
                console.log(`Issue #${issueNum} no tiene la etiqueta 'rfc'. Saltando.`);
                continue;
              }
              
              const hasUser = (issue.data.labels || []).some(l => norm(l.name) === 'user');
              
              let projectId = null;
              if (hasUser) {
                projectId = await getUserProjByNum(PN_USER);
                console.log(`Issue #${issueNum} es de 'user'. Buscando en proyecto USER.`);
              } else {
                projectId = await getUserProjByNum(PN_MAIN) || await getOrgProjByNum(PN_MAIN);
                console.log(`Issue #${issueNum} es un RFC normal. Buscando en proyecto MAIN/ORG.`);
              }
              
              if(!projectId) {
                console.log(`No se pudo encontrar un ID de proyecto (MAIN o USER) para issue #${issueNum}.`);
                continue;
              }
              
              const itemId = await findItemId(projectId, issueNum);
              if (!itemId) {
                console.log(`Issue #${issueNum} no es un item en el proyecto.`);
                continue;
              }
              
              const allFields = await getFields(projectId);
              const fStatus = allFields.find(f => norm(f?.name) === 'status');
              
              if (!fStatus) {
                console.log(`Campo "Status" no encontrado en el proyecto (ID: ${projectId}).`);
                continue;
              }
              
              const success = await setSelect(projectId, itemId, fStatus, 'In Progress');
              
              if (success) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum,
                  body: `## ‚è™ Reabierto

            El Pull Request #${prNumber} fue cerrado sin merge. El estado del issue vuelve a \`In Progress\`.`
                            });
              }
            }

  # --- Job: process-pr-merged (PR Aprobado) ---
  process-pr-merged:
    if: github.event_name == 'pull_request' && github.event.action == 'closed' && github.base_ref == 'main' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Close Linked Issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const pr = context.payload.pull_request;
            const prBody = pr.body || '';
            const prTitle = pr.title || '';
            const prNumber = pr.number;
            const content = prBody + ' ' + prTitle;
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();
            
            const issueRegex = /#(\d+)/gi;
            let match;
            const issueNumbers = new Set();
            
            while ((match = issueRegex.exec(content)) !== null) {
              issueNumbers.add(match[1]);
            }
            
            if (issueNumbers.size === 0) {
              console.log('PR no linkea a ningun issue.');
              return;
            }

            for (const issueNum of issueNumbers) {
              console.log(`Procesando issue #${issueNum} para cierre.`);
              
              let issue;
              try {
                issue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum
                });
              } catch (e) {
                console.log(`No se pudo obtener issue #${issueNum}: ${e.message}`);
                continue;
              }

              if (issue.data.state !== 'open') {
                console.log(`Issue #${issueNum} ya est√° cerrado. Saltando.`);
                continue;
              }
              
              const hasRfc = (issue.data.labels || []).some(l => norm(l.name) === 'rfc');
              if (!hasRfc) {
                console.log(`Issue #${issueNum} no tiene la etiqueta 'rfc'. Saltando.`);
                continue;
              }
              
              try {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum,
                  state: 'closed',
                  state_reason: 'completed'
                });
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNum,
                  body: `## ‚úÖ Completado

            El Pull Request #${prNumber} que resuelve este issue fue fusionado.

            Cerrando issue y actualizando estado del proyecto a \`Done\`.`
                            });

                          } catch (e) {
                            console.log(`No se pudo cerrar o comentar en el issue #${issueNum}: ${e.message}`);
                          }
                        }

  # --- Job: process-ccc-commands ---
  process-ccc-commands:
    if: github.event_name == 'issue_comment' && github.event.action == 'created'
    runs-on: ubuntu-latest
    steps:
      - name: Process Commands
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const comment = context.payload.comment;
            const issue = context.payload.issue;
            const commentBody = (comment.body || '').trim();
            const actor = context.actor;

            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();

            const hasUser = (issue.labels || []).some((l) => norm(l.name) === 'user');
            if (!hasUser) {
              console.log('Issue no tiene label "user". Saltando comandos CCC.');
              return;
            }

            const USER_LOGIN = process.env.USER_LOGIN;
            const ORG_LOGIN = process.env.ORG_LOGIN;
            const PN_USER = parseInt(process.env.PROJECT_NUMBER_USER || '0', 10);

            let isCccMember = false;
            if (ORG_LOGIN) {
              try {
                await github.rest.teams.getMembershipForUserInOrg({
                  org: ORG_LOGIN,
                  team_slug: 'ccc',
                  username: actor
                });
                isCccMember = true;
              } catch (error) {
                if (error.status === 404) {
                  isCccMember = false;
                } else {
                  console.log(`Error al verificar membres√≠a: ${error.message}`);
                  isCccMember = false;
                }
              }
            }

            async function getUserProjByNum(n) {
              const r = await github.graphql(
                `query($login:String!){
                  user(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: USER_LOGIN }
              ).catch(() => null);
              return r?.user?.projectsV2?.nodes?.find((x) => x.number === n)?.id || null;
            }

            async function findItemId(projectId, issueNumber) {
              const r = await github.graphql(
                `query($projectId:ID!, $q:String!){
                  node(id:$projectId){
                    ... on ProjectV2 {
                      items(first:50, query:$q){
                        nodes{
                          id
                          content{ ... on Issue { number } }
                        }
                      }
                    }
                  }
                }`,
                { projectId, q: String(issueNumber) }
              );
              return r.node.items.nodes.find((n) => n.content?.number === issueNumber)?.id || null;
            }

            async function getFields(projectId) {
              const r = await github.graphql(
                `query($projectId:ID!){
                  node(id:$projectId){
                    ... on ProjectV2 {
                      fields(first:100){
                        nodes{
                          ... on ProjectV2FieldCommon { id name dataType }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                        }
                      }
                    }
                  }
                }`,
                { projectId }
              );
              return r.node.fields.nodes;
            }

            async function getFieldValues(itemId) {
              const r = await github.graphql(
                `query($itemId:ID!){
                  node(id:$itemId){
                    ... on ProjectV2Item {
                      fieldValues(first:100){
                        nodes{
                          ... on ProjectV2ItemFieldTextValue {
                            text
                            field { ... on ProjectV2FieldCommon { id name } }
                          }
                          ... on ProjectV2ItemFieldDateValue {
                            date
                            field { ... on ProjectV2FieldCommon { id name } }
                          }
                          ... on ProjectV2ItemFieldSingleSelectValue {
                            name
                            optionId
                            field { ... on ProjectV2FieldCommon { id name } }
                          }
                        }
                      }
                    }
                  }
                }`,
                { itemId }
              );
              return r.node.fieldValues.nodes;
            }

            const by = (fields, names) =>
              names.map((n) => fields.find((f) => norm(f?.name) === norm(n))).find(Boolean);

            if (commentBody === '/verificar') {
              if (!isCccMember) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `@${actor} No tienes permisos para ejecutar este comando. Solo miembros del equipo CCC.`
                });
                return;
              }

              const projectId = await getUserProjByNum(PN_USER);
              if (!projectId) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: '‚ùå No se pudo encontrar el proyecto de usuario.'
                });
                return;
              }

              const itemId = await findItemId(projectId, issue.number);
              if (!itemId) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: '‚ùå Este issue no est√° en el proyecto.'
                });
                return;
              }

              const fields = await getFields(projectId);
              const fChangeType = by(fields, ['Change Type', 'Tipo de cambio']);
              const fImpact = by(fields, ['Impact']);
              const fPlan = by(fields, ['Implementation Plan']);
              const fRollback = by(fields, ['RollBack Planning', 'Rollback Plan']);
              const fPruebas = by(fields, ['Test Planning']);
              const fAprob = by(fields, ['Approvers']);
              const fStart = by(fields, ['Start date']);
              const fTarget = by(fields, ['Target date']);

              const values = await getFieldValues(itemId);
              function getValue(field) {
                if (!field) return null;
                const v = values.find((n) => norm(n.field?.name) === norm(field.name));
                if (!v) return null;
                if ('text' in v) return (v.text || '').trim();
                if ('date' in v) return (v.date || '').trim();
                if ('name' in v) return (v.name || '').trim();
                return null;
              }

              const missing = [];
              if (!getValue(fChangeType)) missing.push('Change Type');
              if (!getValue(fImpact)) missing.push('Impact');
              if (!getValue(fPlan)) missing.push('Implementation Plan');
              if (!getValue(fRollback)) missing.push('RollBack Planning');
              if (!getValue(fPruebas)) missing.push('Test Planning');
              if (!getValue(fAprob)) missing.push('Approvers');
              if (!getValue(fStart)) missing.push('Start date');
              if (!getValue(fTarget)) missing.push('Target date');

              if (missing.length > 0) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `## ‚ùå Campos a√∫n incompletos

              Faltan los siguientes campos en el proyecto:
              ${missing.map((m) => `- \`${m}\``).join('\n')}

              Por favor, completa estos campos en el proyecto y vuelve a ejecutar \`/verificar\`.`
                              });
                            } else {
                              await github.rest.issues.createComment({
                                owner: context.repo.owner,
                                repo: context.repo.repo,
                                issue_number: issue.number,
                                body: `## ‚úÖ Verificaci√≥n Exitosa

              Todos los campos requeridos est√°n completos. Ahora puedes agregar la etiqueta \`approved\` para aprobar el cambio.`
                              });
                            }
                            return;
                          }

            if (commentBody === '/ayuda') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `## üìñ Ayuda - Formulario CCC

              ### Comandos disponibles:
              - \`/verificar\` - Verifica si todos los campos est√°n completos en el proyecto
              - \`/actualizar\` - Actualiza el proyecto con informaci√≥n de este issue
              - \`/ayuda\` - Muestra esta ayuda

              ### Gu√≠a de campos requeridos:

              **Change Type**: Tipo de cambio
              - \`estandar\`: Cambio pre-aprobado, bajo riesgo
              - \`normal\`: Cambio que requiere evaluaci√≥n est√°ndar
              - \`emergencia\`: Cambio urgente para resolver un incidente

              **Impact**: Describe el impacto del cambio
              - Usuarios afectados
              - Sistemas impactados
              - Nivel de criticidad

              **Implementation Plan**: Pasos detallados para implementar
              - Lista numerada de pasos
              - Recursos necesarios
              - Tiempo estimado

              **RollBack Planning**: Plan de reversi√≥n
              - Procedimiento paso a paso para revertir
              - Tiempo estimado de rollback
              - Indicar si es completamente reversible

              **Test Planning**: Estrategia de pruebas
              - Tipos de tests a ejecutar
              - Casos de prueba cr√≠ticos
              - Criterios de aceptaci√≥n

              **Approvers**: Personas que deben aprobar
              - Lista de @usuarios requeridos
              - Tech Lead, Product Owner, DevOps, etc.

              **Start date**: Fecha de inicio (formato: YYYY-MM-DD)  
              **Target date**: Fecha objetivo (formato: YYYY-MM-DD)`
                            });
                            return;
                          }

                          if (commentBody === '/actualizar') {
                            if (!isCccMember) {
                              await github.rest.issues.createComment({
                                owner: context.repo.owner,
                                repo: context.repo.repo,
                                issue_number: issue.number,
                                body: `@${actor} No tienes permisos para ejecutar este comando. Solo miembros del equipo CCC.`
                              });
                              return;
                            }

                            await github.rest.issues.createComment({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: issue.number,
                              body: `## üîÑ Actualizaci√≥n del Proyecto

              El comando \`/actualizar\` permite sincronizar informaci√≥n desde este issue hacia el proyecto.

              **Pr√≥ximamente disponible**: Esta funcionalidad est√° en desarrollo.

              Por ahora, por favor actualiza los campos manualmente en el proyecto y usa \`/verificar\` para confirmar.`
                            });
                            return;
                          }

  # --- Job: set-project-status-on-close ---
  set-project-status-on-close:
    if: github.event_name == 'issues' && github.event.action == 'closed'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const issue = context.payload.issue;
            const hasUser = (issue.labels || []).some(
              (l) => (l.name || '').toLowerCase() === 'user'
            );

            const USER_LOGIN = process.env.USER_LOGIN;
            const ORG_LOGIN  = process.env.ORG_LOGIN;
            const PN_MAIN    = parseInt(process.env.PROJECT_NUMBER,10);
            const PN_USER    = parseInt(process.env.PROJECT_NUMBER_USER||'0',10);

            async function getUserProjByNum(n){
              const r = await github.graphql(
                `query($login:String!){
                  user(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: USER_LOGIN }
              ).catch(()=>null);
              return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }
            async function getOrgProjByNum(n){
              if(!ORG_LOGIN) return null;
              const r = await github.graphql(
                `query($login:String!){
                  organization(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: ORG_LOGIN }
              ).catch(()=>null);
              return r?.organization?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }

            let projectId = null;
            if (hasUser) {
              projectId = await getUserProjByNum(PN_USER);
            } else {
              projectId = await getUserProjByNum(PN_MAIN) || await getOrgProjByNum(PN_MAIN);
            }
            if(!projectId) return;

            const issueNum = issue.number;
            const items = await github.graphql(
              `query($projectId:ID!, $q:String!){
                node(id:$projectId){
                  ... on ProjectV2 {
                    items(first:50, query:$q){
                      nodes{
                        id
                        content{ ... on Issue { number } }
                      }
                    }
                  }
                }
              }`,
              { projectId, q: String(issueNum) }
            );
            const item = items.node.items.nodes.find(n=>n.content?.number===issueNum);
            if(!item) return;

            const fields = await github.graphql(
              `query($projectId:ID!){
                node(id:$projectId){
                  ... on ProjectV2 {
                    fields(first:50){
                      nodes{
                        ... on ProjectV2FieldCommon { id name }
                        ... on ProjectV2SingleSelectField { id name options{ id name } }
                      }
                    }
                  }
                }
              }`,
              { projectId }
            );
            const norm = (s) =>
              (s ?? '')
                .toString()
                .normalize('NFD')
                .replace(/\p{Diacritic}/gu, '')
                .trim()
                .toLowerCase();
            const status = fields.node.fields.nodes.find(f=>norm(f.name)==='status');
            if(!status) return;

            const reason = context.payload.issue.state_reason;
            let optionName = 'Done';
            if (reason !== 'completed') {
               optionName = 'Not Planned';
            }

            const opt = (status.options||[]).find(o=>norm(o.name)===norm(optionName) || norm(o.name)==='no planeado' || norm(o.name)==='done');
            if(!opt) return;

            await github.graphql(
              `mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $opt:String!){
                updateProjectV2ItemFieldValue(input:{
                  projectId:$projectId,
                  itemId:$itemId,
                  fieldId:$fieldId,
                  value:{singleSelectOptionId:$opt}
                }){
                  clientMutationId
                }
              }`,
              { projectId, itemId: item.id, fieldId: status.id, opt: opt.id }
            );

  # --- Job: remove-project-item-on-delete ---
  remove-project-item-on-delete:
    if: github.event_name == 'issues' && github.event.action == 'deleted'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_PAT }}
          script: |
            const issue = context.payload.issue;
            const hasUser = (issue.labels || []).some(
              (l) => (l.name || '').toLowerCase() === 'user'
            );

            const USER_LOGIN = process.env.USER_LOGIN;
            const ORG_LOGIN  = process.env.ORG_LOGIN;
            const PN_MAIN    = parseInt(process.env.PROJECT_NUMBER,10);
            const PN_USER    = parseInt(process.env.PROJECT_NUMBER_USER||'0',10);

            async function getUserProjByNum(n){
              const r = await github.graphql(
                `query($login:String!){
                  user(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: USER_LOGIN }
              ).catch(()=>null);
              return r?.user?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }
            async function getOrgProjByNum(n){
              if(!ORG_LOGIN) return null;
              const r = await github.graphql(
                `query($login:String!){
                  organization(login:$login){
                    projectsV2(first:50){
                      nodes{ id number }
                    }
                  }
                }`,
                { login: ORG_LOGIN }
              ).catch(()=>null);
              return r?.organization?.projectsV2?.nodes?.find(x=>x.number===n)?.id || null;
            }

            let projectId = null;
            if (hasUser) {
              projectId = await getUserProjByNum(PN_USER);
            } else {
              projectId = await getUserProjByNum(PN_MAIN) || await getOrgProjByNum(PN_MAIN);
            }
            if(!projectId) return;

            const items = await github.graphql(
              `query($projectId:ID!, $q:String!){
                node(id:$projectId){
                  ... on ProjectV2 {
                    items(first:50, query:$q){
                      nodes{
                        id
                        content{ ... on Issue { number } }
                      }
                    }
                  }
                }
              }`,
              { projectId, q: String(issue.number) }
            );
            const item = items.node.items.nodes.find(n=>n.content?.number===issue.number);
            if(!item) return;

            await github.graphql(
              `mutation($projectId:ID!, $itemId:ID!){
                deleteProjectV2Item(input:{
                  projectId:$projectId,
                  itemId:$itemId
                }){
                  clientMutationId
                }
              }`,
              { projectId, itemId: item.id }
            );
